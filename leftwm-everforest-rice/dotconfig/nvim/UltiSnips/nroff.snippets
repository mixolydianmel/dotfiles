global !p
def math():
    synlist = vim.eval("""map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')""")

    for syngroup in synlist:
        if 'Equation' in syngroup:
            return True

    return False

# from https://github.com/SirVer/ultisnips/blob/master/doc/examples/tabstop-generation/README.md
def create_matrix_placeholders(snip):
	# Create anonymous snippet body
	anon_snippet_body = ""

	# Get start and end line number of expanded snippet
	start = snip.snippet_start[0]
	end = snip.snippet_end[0]

  # Append current line into anonymous snippet
	for i in range(start, end + 1):
		anon_snippet_body += snip.buffer[i]
		anon_snippet_body += "" if i == end else "\n"

	# Delete expanded snippet line till second to last line
	for i in range(start, end):
		del snip.buffer[start]

	# Empty last expanded snippet line while preserving the line
	snip.buffer[start] = ''

	# Expand anonymous snippet
	snip.expand_anon(anon_snippet_body)

def create_matrix(cols, rows):
	res = ""
	placeholder = 0
	for col in range(0, int(cols)):
		res += "    ccol {\n        "
		placeholder = col + 1;
		res += f"${placeholder}"
		for row in range(0, int(rows) - 1):
			placeholder = int(cols) * (row + 1) + col + 1;
			res += f" above ${placeholder}"
		res += "\n    }\n"
	return res[:-1]
endglobal  

snippet fm "Front Matter" bA
.fam CM
.na
.nr PS 12
.nr PD 0v
.ds CH
.ds RH Henrich %
.P1
.nr HY 0
.EQ
delim $$
define comp \`type "binary" size 7 fat \(ci\`
.EN
endsnippet

snippet hdr "Header" bA
.TL
$1
${3:.AU
$2}
${5:.AI
$4}
${6:.LP}
$0
endsnippet

snippet np "New Problem" bA
.SH
$1
.LP
$0
endsnippet

snippet ip "Unordered Point" bA
.IP $1
$0
endsnippet

snippet dm "Display Math" bA
.EQ
$1
.EN$0
endsnippet

snippet dlm "Display Left Math" bA
.EQ L
$1
.EN$0
endsnippet

snippet mk "Inline Math" wA
$$1$$0
endsnippet

snippet today "Date"
`dat +%F`
endsnippet

context "math()"
snippet sr "Squared" iA
sup 2
endsnippet

context "math()"
snippet cb "Cubed" iA
sup 3
endsnippet

context "math()"
snippet compl "Compliment" iA
sup {c}
endsnippet

context "math()"
snippet td "Superscript" iA
sup { $1 }$0
endsnippet

context "math()"
snippet // "Fraction" iA
{ $1 } over { $2 }$0
endsnippet

context "math()"
snippet '((\d+)|(\d*)(\\)?([A-Za-z]+)((\^|_)(\{\d+\}|\d))*)/' "Fraction" wrA
{ `!p snip.rv = match.group(1)` } over { $1 }$0
endsnippet

context "math()"
priority 1000
snippet '^.*\)/' "() Fraction" wrA
`!p
stripped = match.string[:-1]
depth = 0
i = len(stripped) - 1
while True:
	if stripped[i] == ')': depth += 1
	if stripped[i] == '(': depth -= 1
	if depth == 0: break;
	i -= 1
snip.rv = stripped[0:i] + "{ " + stripped[i+1:-1] + " }"
` over { $1 }$0
endsnippet

context "math()"
snippet pm "Plus or Minus" iA
+-
endsnippet

context "math()"
snippet sq "Square Root" wA
sqrt { $1 }$0
endsnippet

context "math()"
snippet ** "Center Dot" iA
cdot
endsnippet

context "math()"
snippet and "Logical And" wA
\\(AN
endsnippet

context "math()"
snippet or "Logical Or" wA
\\(OR
endsnippet

context "math()"
snippet tt "Roman Text" iA
roman { "$1" }$0
endsnippet

context "math()"
snippet impl "Implies" iA
\\(rA
endsnippet

context "math()"
snippet AA "For All" wA
\\(fa
endsnippet

context "math()"
snippet EE "There Exists" iA
\\(te
endsnippet

context "math()"
snippet cap "Intersection" iA
inter
endsnippet

context "math()"
snippet cup "Union" iA
union
endsnippet

context "math()"
snippet 'in\ ' "Element Of" wrA
\\(mo $0
endsnippet

context "math()"
snippet nin "Not Element Of" iA
\\(nm
endsnippet

context "math()"
snippet {} "Bracket Pair" w
left \{ $1 right \}$0
endsnippet

context "math()"
snippet tf "Therefore" iA
\\(tf
endsnippet

context "math()"
snippet ps "Powerset" iA
\\(wp
endsnippet

context "math()"
snippet ceil "Ceiling Area" iA
left ceiling $1 right ceiling$0
endsnippet

context "math()"
snippet () "Parentheses Pair" w
left ( $1 right )$0
endsnippet

context "math()"
snippet fl "Floor Pair" w
left floor $1 right floor$0
endsnippet

context "math()"
snippet ~~ "Approximately" iA
approx
endsnippet

# context "math()"
# snippet ncr "Choose" iA
# \{$1 \\choose $2\}$0
# endsnippet

context "math()"
snippet sum "Summation Notation" iA
sum from { ${3:${1:n} = ${2:1}} }${5: to {${4:\infty}}}$0
endsnippet

context "math()"
snippet sl "Slash" iA
/
endsnippet

snippet pe "Python Eval"
`!p snip.rv=eval(snip.v.text)`
endsnippet

# context "math()"
# snippet hl "Horizontal Line" wA
# \hline
# endsnippet

# context "math()"
# snippet ... "Dots" wA
# \dots
# endsnippet

context "math()"
snippet m= "Mark Equal" wA
mark =
endsnippet

context "math()"
snippet l= "Lineup Equal" wA
lineup =
endsnippet

snippet ts "Table Start" bA
.TS
tab(@)$1;
$2 .
$3
.TE$0
endsnippet

snippet vop "Vertical Operation" bA
.TS
tab(@);
r l r
r l r 
- s s
r l r .
$1
.TE$0
endsnippet

snippet pc "Pic block" bA
.PS
$1
.PE$0
endsnippet

context "math()"
snippet mtr "Matrix" wA
matrix {
    $1
}$0
endsnippet

context "math()"
snippet lcl "Left Column" wA
lcol {
    $1
}$0
endsnippet

context "math()"
snippet rcl "Right Column" wA
rcol {
    $1
}$0
endsnippet

context "math()"
snippet ccl "Center Column" wA
ccol {
    $1
}$0
endsnippet

snippet bl "Bullet" bA
.IP \(bu 2
$0
endsnippet

snippet ibl "Indented Bullet" bA
.RS
.IP \(bu 2
$1
.RE$0
endsnippet

snippet idt "Indent" bA
.RS
$1
.RE$0
endsnippet

snippet [] "Bracket Pair" w
left [ $1 right ]$0
endsnippet

snippet {} "Brace Pair" w
left { $1 right }$0
endsnippet

snippet lpl "Left Pile" wA
lpile {
    $1
}$0
endsnippet

snippet rpl "Right Pile" wA
rpile {
    $1
}$0
endsnippet

snippet ppl "Pile" wA
pile {
    $1
}$0
endsnippet

snippet || "Bar Pair" w
left | $1 right |$0
endsnippet

context "math()"
snippet '([A-Za-z])(\d)' "auto subscript" wrA
`!p snip.rv = match.group(1)` sub `!p snip.rv = match.group(2)`
endsnippet

context "math()"
snippet '([A-Za-z])\ sub\ (\d\d)' "auto subscript2" wrA
`!p snip.rv = match.group(1)` sub { `!p snip.rv = match.group(2)` }
endsnippet

context "math()"
snippet RR "All Reals" wA
fat roman R
endsnippet

context "math()"
snippet cvec "Column Vector" wA
left [ pile {
    $1
} right ]$0
endsnippet

post_jump "create_matrix_placeholders(snip)"
snippet 'mat\ (\d+),(\d+)' "Matrix with Dimensions" wr
left [ matrix {
`!p
snip.rv = create_matrix(match.group(2), match.group(1))
`$0
} right ]
endsnippet

snippet a= "Mark Equals" wA
mark = $0
endsnippet

snippet e= "Lineup Equals" wA
lineup = $0
endsnippet

snippet lim "Limit" wA
limit from { ${1:n} } to { ${2:inf} }
endsnippet

snippet prod "Product" wA
prod from { ${1:n=${2:1}} } to { ${3:inf} } ${4:${VISUAL}} $0
endsnippet

snippet ooo "Infinity" wA
inf
endsnippet

snippet __ "Subscript" iA
 sub { $1 }$0
endsnippet

snippet xnn "xn" iA
x sub n
endsnippet

snippet xmm "xm" iA
x sub m
endsnippet

snippet xii "xi" iA
x sub i
endsnippet

snippet xjj "xj" iA
x sub j
endsnippet

snippet R0+ "R0+" iA
R sub 0 sup +
endsnippet

snippet xx "Cross" iA
times
endsnippet

snippet norm "Normalized" iA
\| $1 \|$0
endsnippet

snippet len "Length" iA
\|\| $1 \|\|$0
endsnippet

snippet dint "Integral" wA
int from { ${1:- inf} } to { ${2:inf} } ${3:${VISUAL}} $0
endsnippet

snippet invs "Inverse" iA
sup { -1 }
endsnippet


