var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  __markAsModule(target);
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  if (module2 && module2.__esModule)
    return module2;
  return __exportStar(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", {value: module2, enumerable: true}), module2);
};

// node_modules/colors/lib/styles.js
var require_styles = __commonJS((exports2, module2) => {
  var styles2 = {};
  module2["exports"] = styles2;
  var codes = {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29],
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    gray: [90, 39],
    grey: [90, 39],
    brightRed: [91, 39],
    brightGreen: [92, 39],
    brightYellow: [93, 39],
    brightBlue: [94, 39],
    brightMagenta: [95, 39],
    brightCyan: [96, 39],
    brightWhite: [97, 39],
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    bgGray: [100, 49],
    bgGrey: [100, 49],
    bgBrightRed: [101, 49],
    bgBrightGreen: [102, 49],
    bgBrightYellow: [103, 49],
    bgBrightBlue: [104, 49],
    bgBrightMagenta: [105, 49],
    bgBrightCyan: [106, 49],
    bgBrightWhite: [107, 49],
    blackBG: [40, 49],
    redBG: [41, 49],
    greenBG: [42, 49],
    yellowBG: [43, 49],
    blueBG: [44, 49],
    magentaBG: [45, 49],
    cyanBG: [46, 49],
    whiteBG: [47, 49]
  };
  Object.keys(codes).forEach(function(key) {
    var val = codes[key];
    var style = styles2[key] = [];
    style.open = "[" + val[0] + "m";
    style.close = "[" + val[1] + "m";
  });
});

// node_modules/colors/lib/system/has-flag.js
var require_has_flag = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(flag, argv) {
    argv = argv || process.argv;
    var terminatorPos = argv.indexOf("--");
    var prefix = /^-{1,2}/.test(flag) ? "" : "--";
    var pos = argv.indexOf(prefix + flag);
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };
});

// node_modules/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS((exports2, module2) => {
  "use strict";
  var os2 = require("os");
  var hasFlag = require_has_flag();
  var env = process.env;
  var forceColor = void 0;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
    forceColor = false;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env) {
    forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(stream) {
    if (forceColor === false) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (stream && !stream.isTTY && forceColor !== true) {
      return 0;
    }
    var min = forceColor ? 1 : 0;
    if (process.platform === "win32") {
      var osRelease = os2.release().split(".");
      if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign) {
        return sign in env;
      }) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if ("TERM_PROGRAM" in env) {
      var version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Hyper":
          return 3;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    if (env.TERM === "dumb") {
      return min;
    }
    return min;
  }
  function getSupportLevel(stream) {
    var level = supportsColor(stream);
    return translateLevel(level);
  }
  module2.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };
});

// node_modules/colors/lib/custom/trap.js
var require_trap = __commonJS((exports2, module2) => {
  module2["exports"] = function runTheTrap(text, options2) {
    var result = "";
    text = text || "Run the trap, drop the bass";
    text = text.split("");
    var trap = {
      a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
      b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
      c: ["\xA9", "\u023B", "\u03FE"],
      d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
      e: [
        "\xCB",
        "\u0115",
        "\u018E",
        "\u0258",
        "\u03A3",
        "\u03BE",
        "\u04BC",
        "\u0A6C"
      ],
      f: ["\u04FA"],
      g: ["\u0262"],
      h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
      i: ["\u0F0F"],
      j: ["\u0134"],
      k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
      l: ["\u0139"],
      m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
      n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
      o: [
        "\xD8",
        "\xF5",
        "\xF8",
        "\u01FE",
        "\u0298",
        "\u047A",
        "\u05DD",
        "\u06DD",
        "\u0E4F"
      ],
      p: ["\u01F7", "\u048E"],
      q: ["\u09CD"],
      r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
      s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
      t: ["\u0141", "\u0166", "\u0373"],
      u: ["\u01B1", "\u054D"],
      v: ["\u05D8"],
      w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
      x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
      y: ["\xA5", "\u04B0", "\u04CB"],
      z: ["\u01B5", "\u0240"]
    };
    text.forEach(function(c) {
      c = c.toLowerCase();
      var chars = trap[c] || [" "];
      var rand = Math.floor(Math.random() * chars.length);
      if (typeof trap[c] !== "undefined") {
        result += trap[c][rand];
      } else {
        result += c;
      }
    });
    return result;
  };
});

// node_modules/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS((exports2, module2) => {
  module2["exports"] = function zalgo(text, options2) {
    text = text || "   he is here   ";
    var soul = {
      up: [
        "\u030D",
        "\u030E",
        "\u0304",
        "\u0305",
        "\u033F",
        "\u0311",
        "\u0306",
        "\u0310",
        "\u0352",
        "\u0357",
        "\u0351",
        "\u0307",
        "\u0308",
        "\u030A",
        "\u0342",
        "\u0313",
        "\u0308",
        "\u034A",
        "\u034B",
        "\u034C",
        "\u0303",
        "\u0302",
        "\u030C",
        "\u0350",
        "\u0300",
        "\u0301",
        "\u030B",
        "\u030F",
        "\u0312",
        "\u0313",
        "\u0314",
        "\u033D",
        "\u0309",
        "\u0363",
        "\u0364",
        "\u0365",
        "\u0366",
        "\u0367",
        "\u0368",
        "\u0369",
        "\u036A",
        "\u036B",
        "\u036C",
        "\u036D",
        "\u036E",
        "\u036F",
        "\u033E",
        "\u035B",
        "\u0346",
        "\u031A"
      ],
      down: [
        "\u0316",
        "\u0317",
        "\u0318",
        "\u0319",
        "\u031C",
        "\u031D",
        "\u031E",
        "\u031F",
        "\u0320",
        "\u0324",
        "\u0325",
        "\u0326",
        "\u0329",
        "\u032A",
        "\u032B",
        "\u032C",
        "\u032D",
        "\u032E",
        "\u032F",
        "\u0330",
        "\u0331",
        "\u0332",
        "\u0333",
        "\u0339",
        "\u033A",
        "\u033B",
        "\u033C",
        "\u0345",
        "\u0347",
        "\u0348",
        "\u0349",
        "\u034D",
        "\u034E",
        "\u0353",
        "\u0354",
        "\u0355",
        "\u0356",
        "\u0359",
        "\u035A",
        "\u0323"
      ],
      mid: [
        "\u0315",
        "\u031B",
        "\u0300",
        "\u0301",
        "\u0358",
        "\u0321",
        "\u0322",
        "\u0327",
        "\u0328",
        "\u0334",
        "\u0335",
        "\u0336",
        "\u035C",
        "\u035D",
        "\u035E",
        "\u035F",
        "\u0360",
        "\u0362",
        "\u0338",
        "\u0337",
        "\u0361",
        " \u0489"
      ]
    };
    var all = [].concat(soul.up, soul.down, soul.mid);
    function randomNumber(range) {
      var r = Math.floor(Math.random() * range);
      return r;
    }
    function isChar(character) {
      var bool = false;
      all.filter(function(i) {
        bool = i === character;
      });
      return bool;
    }
    function heComes(text2, options3) {
      var result = "";
      var counts;
      var l;
      options3 = options3 || {};
      options3["up"] = typeof options3["up"] !== "undefined" ? options3["up"] : true;
      options3["mid"] = typeof options3["mid"] !== "undefined" ? options3["mid"] : true;
      options3["down"] = typeof options3["down"] !== "undefined" ? options3["down"] : true;
      options3["size"] = typeof options3["size"] !== "undefined" ? options3["size"] : "maxi";
      text2 = text2.split("");
      for (l in text2) {
        if (isChar(l)) {
          continue;
        }
        result = result + text2[l];
        counts = {up: 0, down: 0, mid: 0};
        switch (options3.size) {
          case "mini":
            counts.up = randomNumber(8);
            counts.mid = randomNumber(2);
            counts.down = randomNumber(8);
            break;
          case "maxi":
            counts.up = randomNumber(16) + 3;
            counts.mid = randomNumber(4) + 1;
            counts.down = randomNumber(64) + 3;
            break;
          default:
            counts.up = randomNumber(8) + 1;
            counts.mid = randomNumber(6) / 2;
            counts.down = randomNumber(8) + 1;
            break;
        }
        var arr = ["up", "mid", "down"];
        for (var d in arr) {
          var index = arr[d];
          for (var i = 0; i <= counts[index]; i++) {
            if (options3[index]) {
              result = result + soul[index][randomNumber(soul[index].length)];
            }
          }
        }
      }
      return result;
    }
    return heComes(text, options2);
  };
});

// node_modules/colors/lib/maps/america.js
var require_america = __commonJS((exports2, module2) => {
  module2["exports"] = function(colors10) {
    return function(letter, i, exploded) {
      if (letter === " ")
        return letter;
      switch (i % 3) {
        case 0:
          return colors10.red(letter);
        case 1:
          return colors10.white(letter);
        case 2:
          return colors10.blue(letter);
      }
    };
  };
});

// node_modules/colors/lib/maps/zebra.js
var require_zebra = __commonJS((exports2, module2) => {
  module2["exports"] = function(colors10) {
    return function(letter, i, exploded) {
      return i % 2 === 0 ? letter : colors10.inverse(letter);
    };
  };
});

// node_modules/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS((exports2, module2) => {
  module2["exports"] = function(colors10) {
    var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
    return function(letter, i, exploded) {
      if (letter === " ") {
        return letter;
      } else {
        return colors10[rainbowColors[i++ % rainbowColors.length]](letter);
      }
    };
  };
});

// node_modules/colors/lib/maps/random.js
var require_random = __commonJS((exports2, module2) => {
  module2["exports"] = function(colors10) {
    var available = [
      "underline",
      "inverse",
      "grey",
      "yellow",
      "red",
      "green",
      "blue",
      "white",
      "cyan",
      "magenta",
      "brightYellow",
      "brightRed",
      "brightGreen",
      "brightBlue",
      "brightWhite",
      "brightCyan",
      "brightMagenta"
    ];
    return function(letter, i, exploded) {
      return letter === " " ? letter : colors10[available[Math.round(Math.random() * (available.length - 2))]](letter);
    };
  };
});

// node_modules/colors/lib/colors.js
var require_colors = __commonJS((exports2, module2) => {
  var colors10 = {};
  module2["exports"] = colors10;
  colors10.themes = {};
  var util2 = require("util");
  var ansiStyles = colors10.styles = require_styles();
  var defineProps = Object.defineProperties;
  var newLineRegex = new RegExp(/[\r\n]+/g);
  colors10.supportsColor = require_supports_colors().supportsColor;
  if (typeof colors10.enabled === "undefined") {
    colors10.enabled = colors10.supportsColor() !== false;
  }
  colors10.enable = function() {
    colors10.enabled = true;
  };
  colors10.disable = function() {
    colors10.enabled = false;
  };
  colors10.stripColors = colors10.strip = function(str) {
    return ("" + str).replace(/\x1B\[\d+m/g, "");
  };
  var stylize = colors10.stylize = function stylize2(str, style) {
    if (!colors10.enabled) {
      return str + "";
    }
    var styleMap = ansiStyles[style];
    if (!styleMap && style in colors10) {
      return colors10[style](str);
    }
    return styleMap.open + str + styleMap.close;
  };
  var matchOperatorsRe2 = /[|\\{}()[\]^$+*?.]/g;
  var escapeStringRegexp = function(str) {
    if (typeof str !== "string") {
      throw new TypeError("Expected a string");
    }
    return str.replace(matchOperatorsRe2, "\\$&");
  };
  function build(_styles) {
    var builder = function builder2() {
      return applyStyle.apply(builder2, arguments);
    };
    builder._styles = _styles;
    builder.__proto__ = proto;
    return builder;
  }
  var styles2 = function() {
    var ret = {};
    ansiStyles.grey = ansiStyles.gray;
    Object.keys(ansiStyles).forEach(function(key) {
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
      ret[key] = {
        get: function() {
          return build(this._styles.concat(key));
        }
      };
    });
    return ret;
  }();
  var proto = defineProps(function colors11() {
  }, styles2);
  function applyStyle() {
    var args = Array.prototype.slice.call(arguments);
    var str = args.map(function(arg) {
      if (arg != null && arg.constructor === String) {
        return arg;
      } else {
        return util2.inspect(arg);
      }
    }).join(" ");
    if (!colors10.enabled || !str) {
      return str;
    }
    var newLinesPresent = str.indexOf("\n") != -1;
    var nestedStyles = this._styles;
    var i = nestedStyles.length;
    while (i--) {
      var code = ansiStyles[nestedStyles[i]];
      str = code.open + str.replace(code.closeRe, code.open) + code.close;
      if (newLinesPresent) {
        str = str.replace(newLineRegex, function(match) {
          return code.close + match + code.open;
        });
      }
    }
    return str;
  }
  colors10.setTheme = function(theme) {
    if (typeof theme === "string") {
      console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
      return;
    }
    for (var style in theme) {
      (function(style2) {
        colors10[style2] = function(str) {
          if (typeof theme[style2] === "object") {
            var out = str;
            for (var i in theme[style2]) {
              out = colors10[theme[style2][i]](out);
            }
            return out;
          }
          return colors10[theme[style2]](str);
        };
      })(style);
    }
  };
  function init() {
    var ret = {};
    Object.keys(styles2).forEach(function(name) {
      ret[name] = {
        get: function() {
          return build([name]);
        }
      };
    });
    return ret;
  }
  var sequencer = function sequencer2(map2, str) {
    var exploded = str.split("");
    exploded = exploded.map(map2);
    return exploded.join("");
  };
  colors10.trap = require_trap();
  colors10.zalgo = require_zalgo();
  colors10.maps = {};
  colors10.maps.america = require_america()(colors10);
  colors10.maps.zebra = require_zebra()(colors10);
  colors10.maps.rainbow = require_rainbow()(colors10);
  colors10.maps.random = require_random()(colors10);
  for (var map in colors10.maps) {
    (function(map2) {
      colors10[map2] = function(str) {
        return sequencer(colors10.maps[map2], str);
      };
    })(map);
  }
  defineProps(colors10, init());
});

// node_modules/colors/safe.js
var require_safe = __commonJS((exports2, module2) => {
  var colors10 = require_colors();
  module2["exports"] = colors10;
});

// node_modules/isexe/windows.js
var require_windows = __commonJS((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync;
  var fs7 = require("fs");
  function checkPathExt(path9, options2) {
    var pathext = options2.pathExt !== void 0 ? options2.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0; i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path9.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat, path9, options2) {
    if (!stat.isSymbolicLink() && !stat.isFile()) {
      return false;
    }
    return checkPathExt(path9, options2);
  }
  function isexe(path9, options2, cb) {
    fs7.stat(path9, function(er, stat) {
      cb(er, er ? false : checkStat(stat, path9, options2));
    });
  }
  function sync(path9, options2) {
    return checkStat(fs7.statSync(path9), path9, options2);
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS((exports2, module2) => {
  module2.exports = isexe;
  isexe.sync = sync;
  var fs7 = require("fs");
  function isexe(path9, options2, cb) {
    fs7.stat(path9, function(er, stat) {
      cb(er, er ? false : checkStat(stat, options2));
    });
  }
  function sync(path9, options2) {
    return checkStat(fs7.statSync(path9), options2);
  }
  function checkStat(stat, options2) {
    return stat.isFile() && checkMode(stat, options2);
  }
  function checkMode(stat, options2) {
    var mod = stat.mode;
    var uid = stat.uid;
    var gid = stat.gid;
    var myUid = options2.uid !== void 0 ? options2.uid : process.getuid && process.getuid();
    var myGid = options2.gid !== void 0 ? options2.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS((exports2, module2) => {
  var fs7 = require("fs");
  var core;
  if (process.platform === "win32" || global.TESTING_WINDOWS) {
    core = require_windows();
  } else {
    core = require_mode();
  }
  module2.exports = isexe;
  isexe.sync = sync;
  function isexe(path9, options2, cb) {
    if (typeof options2 === "function") {
      cb = options2;
      options2 = {};
    }
    if (!cb) {
      if (typeof Promise !== "function") {
        throw new TypeError("callback not provided");
      }
      return new Promise(function(resolve, reject) {
        isexe(path9, options2 || {}, function(er, is) {
          if (er) {
            reject(er);
          } else {
            resolve(is);
          }
        });
      });
    }
    core(path9, options2 || {}, function(er, is) {
      if (er) {
        if (er.code === "EACCES" || options2 && options2.ignoreErrors) {
          er = null;
          is = false;
        }
      }
      cb(er, is);
    });
  }
  function sync(path9, options2) {
    try {
      return core.sync(path9, options2 || {});
    } catch (er) {
      if (options2 && options2.ignoreErrors || er.code === "EACCES") {
        return false;
      } else {
        throw er;
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS((exports2, module2) => {
  var isWindows2 = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
  var path9 = require("path");
  var COLON = isWindows2 ? ";" : ":";
  var isexe = require_isexe();
  var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), {code: "ENOENT"});
  var getPathInfo = (cmd, opt) => {
    const colon = opt.colon || COLON;
    const pathEnv = cmd.match(/\//) || isWindows2 && cmd.match(/\\/) ? [""] : [
      ...isWindows2 ? [process.cwd()] : [],
      ...(opt.path || process.env.PATH || "").split(colon)
    ];
    const pathExtExe = isWindows2 ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
    const pathExt = isWindows2 ? pathExtExe.split(colon) : [""];
    if (isWindows2) {
      if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
        pathExt.unshift("");
    }
    return {
      pathEnv,
      pathExt,
      pathExtExe
    };
  };
  var which2 = (cmd, opt, cb) => {
    if (typeof opt === "function") {
      cb = opt;
      opt = {};
    }
    if (!opt)
      opt = {};
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
    const found = [];
    const step = (i) => new Promise((resolve, reject) => {
      if (i === pathEnv.length)
        return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path9.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      resolve(subStep(p, i, 0));
    });
    const subStep = (p, i, ii) => new Promise((resolve, reject) => {
      if (ii === pathExt.length)
        return resolve(step(i + 1));
      const ext = pathExt[ii];
      isexe(p + ext, {pathExt: pathExtExe}, (er, is) => {
        if (!er && is) {
          if (opt.all)
            found.push(p + ext);
          else
            return resolve(p + ext);
        }
        return resolve(subStep(p, i, ii + 1));
      });
    });
    return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
  };
  var whichSync = (cmd, opt) => {
    opt = opt || {};
    const {pathEnv, pathExt, pathExtExe} = getPathInfo(cmd, opt);
    const found = [];
    for (let i = 0; i < pathEnv.length; i++) {
      const ppRaw = pathEnv[i];
      const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
      const pCmd = path9.join(pathPart, cmd);
      const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
      for (let j = 0; j < pathExt.length; j++) {
        const cur = p + pathExt[j];
        try {
          const is = isexe.sync(cur, {pathExt: pathExtExe});
          if (is) {
            if (opt.all)
              found.push(cur);
            else
              return cur;
          }
        } catch (ex) {
        }
      }
    }
    if (opt.all && found.length)
      return found;
    if (opt.nothrow)
      return null;
    throw getNotFoundError(cmd);
  };
  module2.exports = which2;
  which2.sync = whichSync;
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS((exports2, module2) => {
  module2.exports = function(xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
      var x = fn(xs[i], i);
      if (isArray(x))
        res.push.apply(res, x);
      else
        res.push(x);
    }
    return res;
  };
  var isArray = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = balanced;
  function balanced(a, b, str) {
    if (a instanceof RegExp)
      a = maybeMatch(a, str);
    if (b instanceof RegExp)
      b = maybeMatch(b, str);
    var r = range(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }
  balanced.range = range;
  function range(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
      begs = [];
      left = str.length;
      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b, i + 1);
        }
        i = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS((exports2, module2) => {
  var concatMap = require_concat_map();
  var balanced = require_balanced_match();
  module2.exports = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0";
  var escOpen = "\0OPEN" + Math.random() + "\0";
  var escClose = "\0CLOSE" + Math.random() + "\0";
  var escComma = "\0COMMA" + Math.random() + "\0";
  var escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m = balanced("{", "}", str);
    if (!m)
      return str.split(",");
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }
  function expand(str, isTop) {
    var expansions = [];
    var m = balanced("{", "}", str);
    if (!m || /\$$/.test(m.pre))
      return [str];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,.*\}/)) {
        str = m.pre + "{" + m.body + escClose + m.post;
        return expand(str);
      }
      return [str];
    }
    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1) {
        n = expand(n[0], false).map(embrace);
        if (n.length === 1) {
          var post = m.post.length ? expand(m.post, false) : [""];
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }
    var pre = m.pre;
    var post = m.post.length ? expand(m.post, false) : [""];
    var N;
    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length);
      var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad2 = n.some(isPadded);
      N = [];
      for (var i = x; test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === "\\")
            c = "";
        } else {
          c = String(i);
          if (pad2) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              if (i < 0)
                c = "-" + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = concatMap(n, function(el) {
        return expand(el, false);
      });
    }
    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
    return expansions;
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS((exports2, module2) => {
  module2.exports = minimatch4;
  minimatch4.Minimatch = Minimatch;
  var path9 = {sep: "/"};
  try {
    path9 = require("path");
  } catch (er) {
  }
  var GLOBSTAR = minimatch4.GLOBSTAR = Minimatch.GLOBSTAR = {};
  var expand = require_brace_expansion();
  var plTypes = {
    "!": {open: "(?:(?!(?:", close: "))[^/]*?)"},
    "?": {open: "(?:", close: ")?"},
    "+": {open: "(?:", close: ")+"},
    "*": {open: "(?:", close: ")*"},
    "@": {open: "(?:", close: ")"}
  };
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var reSpecials = charSet("().*{}+?[]^$\\!");
  function charSet(s) {
    return s.split("").reduce(function(set, c) {
      set[c] = true;
      return set;
    }, {});
  }
  var slashSplit = /\/+/;
  minimatch4.filter = filter;
  function filter(pattern, options2) {
    options2 = options2 || {};
    return function(p, i, list) {
      return minimatch4(p, pattern, options2);
    };
  }
  function ext(a, b) {
    a = a || {};
    b = b || {};
    var t = {};
    Object.keys(b).forEach(function(k) {
      t[k] = b[k];
    });
    Object.keys(a).forEach(function(k) {
      t[k] = a[k];
    });
    return t;
  }
  minimatch4.defaults = function(def) {
    if (!def || !Object.keys(def).length)
      return minimatch4;
    var orig = minimatch4;
    var m = function minimatch5(p, pattern, options2) {
      return orig.minimatch(p, pattern, ext(def, options2));
    };
    m.Minimatch = function Minimatch2(pattern, options2) {
      return new orig.Minimatch(pattern, ext(def, options2));
    };
    return m;
  };
  Minimatch.defaults = function(def) {
    if (!def || !Object.keys(def).length)
      return Minimatch;
    return minimatch4.defaults(def).Minimatch;
  };
  function minimatch4(p, pattern, options2) {
    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required");
    }
    if (!options2)
      options2 = {};
    if (!options2.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    if (pattern.trim() === "")
      return p === "";
    return new Minimatch(pattern, options2).match(p);
  }
  function Minimatch(pattern, options2) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern, options2);
    }
    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required");
    }
    if (!options2)
      options2 = {};
    pattern = pattern.trim();
    if (path9.sep !== "/") {
      pattern = pattern.split(path9.sep).join("/");
    }
    this.options = options2;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.make();
  }
  Minimatch.prototype.debug = function() {
  };
  Minimatch.prototype.make = make;
  function make() {
    if (this._made)
      return;
    var pattern = this.pattern;
    var options2 = this.options;
    if (!options2.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    var set = this.globSet = this.braceExpand();
    if (options2.debug)
      this.debug = console.error;
    this.debug(this.pattern, set);
    set = this.globParts = set.map(function(s) {
      return s.split(slashSplit);
    });
    this.debug(this.pattern, set);
    set = set.map(function(s, si, set2) {
      return s.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set);
    set = set.filter(function(s) {
      return s.indexOf(false) === -1;
    });
    this.debug(this.pattern, set);
    this.set = set;
  }
  Minimatch.prototype.parseNegate = parseNegate;
  function parseNegate() {
    var pattern = this.pattern;
    var negate = false;
    var options2 = this.options;
    var negateOffset = 0;
    if (options2.nonegate)
      return;
    for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
  }
  minimatch4.braceExpand = function(pattern, options2) {
    return braceExpand(pattern, options2);
  };
  Minimatch.prototype.braceExpand = braceExpand;
  function braceExpand(pattern, options2) {
    if (!options2) {
      if (this instanceof Minimatch) {
        options2 = this.options;
      } else {
        options2 = {};
      }
    }
    pattern = typeof pattern === "undefined" ? this.pattern : pattern;
    if (typeof pattern === "undefined") {
      throw new TypeError("undefined pattern");
    }
    if (options2.nobrace || !pattern.match(/\{.*\}/)) {
      return [pattern];
    }
    return expand(pattern);
  }
  Minimatch.prototype.parse = parse;
  var SUBPARSE = {};
  function parse(pattern, isSub) {
    if (pattern.length > 1024 * 64) {
      throw new TypeError("pattern is too long");
    }
    var options2 = this.options;
    if (!options2.noglobstar && pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    var re = "";
    var hasMagic = !!options2.nocase;
    var escaping = false;
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    var patternStart = pattern.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    var self = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star;
            hasMagic = true;
            break;
          case "?":
            re += qmark;
            hasMagic = true;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        self.debug("clearStateChar %j %j", stateChar, re);
        stateChar = false;
      }
    }
    for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
      this.debug("%s	%s %s %j", pattern, i, re, c);
      if (escaping && reSpecials[c]) {
        re += "\\" + c;
        escaping = false;
        continue;
      }
      switch (c) {
        case "/":
          return false;
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
          if (inClass) {
            this.debug("  in class");
            if (c === "!" && i === classStart + 1)
              c = "^";
            re += c;
            continue;
          }
          self.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c;
          if (options2.noext)
            clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
          this.debug("plType %j %j", stateChar, re);
          stateChar = false;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re += "\\)";
            continue;
          }
          clearStateChar();
          hasMagic = true;
          var pl = patternListStack.pop();
          re += pl.close;
          if (pl.type === "!") {
            negativeLists.push(pl);
          }
          pl.reEnd = re.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re += "\\|";
            escaping = false;
            continue;
          }
          clearStateChar();
          re += "|";
          continue;
        case "[":
          clearStateChar();
          if (inClass) {
            re += "\\" + c;
            continue;
          }
          inClass = true;
          classStart = i;
          reClassStart = re.length;
          re += c;
          continue;
        case "]":
          if (i === classStart + 1 || !inClass) {
            re += "\\" + c;
            escaping = false;
            continue;
          }
          if (inClass) {
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
          }
          hasMagic = true;
          inClass = false;
          re += c;
          continue;
        default:
          clearStateChar();
          if (escaping) {
            escaping = false;
          } else if (reSpecials[c] && !(c === "^" && inClass)) {
            re += "\\";
          }
          re += c;
      }
    }
    if (inClass) {
      cs = pattern.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re = re.substr(0, reClassStart) + "\\[" + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug("tail=%j\n   %s", tail, tail, pl, re);
      var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re += "\\\\";
    }
    var addPatternStart = false;
    switch (re.charAt(0)) {
      case ".":
      case "[":
      case "(":
        addPatternStart = true;
    }
    for (var n = negativeLists.length - 1; n > -1; n--) {
      var nl = negativeLists[n];
      var nlBefore = re.slice(0, nl.reStart);
      var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
      var nlAfter = re.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1;
      var cleanAfter = nlAfter;
      for (i = 0; i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      var dollar = "";
      if (nlAfter === "" && isSub !== SUBPARSE) {
        dollar = "$";
      }
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re = newRe;
    }
    if (re !== "" && hasMagic) {
      re = "(?=.)" + re;
    }
    if (addPatternStart) {
      re = patternStart + re;
    }
    if (isSub === SUBPARSE) {
      return [re, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern);
    }
    var flags = options2.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re + "$", flags);
    } catch (er) {
      return new RegExp("$.");
    }
    regExp._glob = pattern;
    regExp._src = re;
    return regExp;
  }
  minimatch4.makeRe = function(pattern, options2) {
    return new Minimatch(pattern, options2 || {}).makeRe();
  };
  Minimatch.prototype.makeRe = makeRe;
  function makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    var set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    var options2 = this.options;
    var twoStar = options2.noglobstar ? star : options2.dot ? twoStarDot : twoStarNoDot;
    var flags = options2.nocase ? "i" : "";
    var re = set.map(function(pattern) {
      return pattern.map(function(p) {
        return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
      }).join("\\/");
    }).join("|");
    re = "^(?:" + re + ")$";
    if (this.negate)
      re = "^(?!" + re + ").*$";
    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  minimatch4.match = function(list, pattern, options2) {
    options2 = options2 || {};
    var mm = new Minimatch(pattern, options2);
    list = list.filter(function(f) {
      return mm.match(f);
    });
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  Minimatch.prototype.match = match;
  function match(f, partial) {
    this.debug("match", f, this.pattern);
    if (this.comment)
      return false;
    if (this.empty)
      return f === "";
    if (f === "/" && partial)
      return true;
    var options2 = this.options;
    if (path9.sep !== "/") {
      f = f.split(path9.sep).join("/");
    }
    f = f.split(slashSplit);
    this.debug(this.pattern, "split", f);
    var set = this.set;
    this.debug(this.pattern, "set", set);
    var filename;
    var i;
    for (i = f.length - 1; i >= 0; i--) {
      filename = f[i];
      if (filename)
        break;
    }
    for (i = 0; i < set.length; i++) {
      var pattern = set[i];
      var file = f;
      if (options2.matchBase && pattern.length === 1) {
        file = [filename];
      }
      var hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options2.flipNegate)
          return true;
        return !this.negate;
      }
    }
    if (options2.flipNegate)
      return false;
    return this.negate;
  }
  Minimatch.prototype.matchOne = function(file, pattern, partial) {
    var options2 = this.options;
    this.debug("matchOne", {this: this, file, pattern});
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false)
        return false;
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options2.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl)
            return true;
        }
        return false;
      }
      var hit;
      if (typeof p === "string") {
        if (options2.nocase) {
          hit = f.toLowerCase() === p.toLowerCase();
        } else {
          hit = f === p;
        }
        this.debug("string match", p, f, hit);
      } else {
        hit = f.match(p);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      var emptyFileEnd = fi === fl - 1 && file[fi] === "";
      return emptyFileEnd;
    }
    throw new Error("wtf?");
  };
  function globUnescape(s) {
    return s.replace(/\\(.)/g, "$1");
  }
  function regExpEscape(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
});

// node_modules/mkdirp/lib/opts-arg.js
var require_opts_arg = __commonJS((exports2, module2) => {
  var {promisify: promisify2} = require("util");
  var fs7 = require("fs");
  var optsArg = (opts) => {
    if (!opts)
      opts = {mode: 511, fs: fs7};
    else if (typeof opts === "object")
      opts = {mode: 511, fs: fs7, ...opts};
    else if (typeof opts === "number")
      opts = {mode: opts, fs: fs7};
    else if (typeof opts === "string")
      opts = {mode: parseInt(opts, 8), fs: fs7};
    else
      throw new TypeError("invalid options argument");
    opts.mkdir = opts.mkdir || opts.fs.mkdir || fs7.mkdir;
    opts.mkdirAsync = promisify2(opts.mkdir);
    opts.stat = opts.stat || opts.fs.stat || fs7.stat;
    opts.statAsync = promisify2(opts.stat);
    opts.statSync = opts.statSync || opts.fs.statSync || fs7.statSync;
    opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs7.mkdirSync;
    return opts;
  };
  module2.exports = optsArg;
});

// node_modules/mkdirp/lib/path-arg.js
var require_path_arg = __commonJS((exports2, module2) => {
  var platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
  var {resolve, parse} = require("path");
  var pathArg = (path9) => {
    if (/\0/.test(path9)) {
      throw Object.assign(new TypeError("path must be a string without null bytes"), {
        path: path9,
        code: "ERR_INVALID_ARG_VALUE"
      });
    }
    path9 = resolve(path9);
    if (platform === "win32") {
      const badWinChars = /[*|"<>?:]/;
      const {root} = parse(path9);
      if (badWinChars.test(path9.substr(root.length))) {
        throw Object.assign(new Error("Illegal characters in path."), {
          path: path9,
          code: "EINVAL"
        });
      }
    }
    return path9;
  };
  module2.exports = pathArg;
});

// node_modules/mkdirp/lib/find-made.js
var require_find_made = __commonJS((exports2, module2) => {
  var {dirname} = require("path");
  var findMade = (opts, parent, path9 = void 0) => {
    if (path9 === parent)
      return Promise.resolve();
    return opts.statAsync(parent).then((st) => st.isDirectory() ? path9 : void 0, (er) => er.code === "ENOENT" ? findMade(opts, dirname(parent), parent) : void 0);
  };
  var findMadeSync = (opts, parent, path9 = void 0) => {
    if (path9 === parent)
      return void 0;
    try {
      return opts.statSync(parent).isDirectory() ? path9 : void 0;
    } catch (er) {
      return er.code === "ENOENT" ? findMadeSync(opts, dirname(parent), parent) : void 0;
    }
  };
  module2.exports = {findMade, findMadeSync};
});

// node_modules/mkdirp/lib/mkdirp-manual.js
var require_mkdirp_manual = __commonJS((exports2, module2) => {
  var {dirname} = require("path");
  var mkdirpManual = (path9, opts, made) => {
    opts.recursive = false;
    const parent = dirname(path9);
    if (parent === path9) {
      return opts.mkdirAsync(path9, opts).catch((er) => {
        if (er.code !== "EISDIR")
          throw er;
      });
    }
    return opts.mkdirAsync(path9, opts).then(() => made || path9, (er) => {
      if (er.code === "ENOENT")
        return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path9, opts, made2));
      if (er.code !== "EEXIST" && er.code !== "EROFS")
        throw er;
      return opts.statAsync(path9).then((st) => {
        if (st.isDirectory())
          return made;
        else
          throw er;
      }, () => {
        throw er;
      });
    });
  };
  var mkdirpManualSync = (path9, opts, made) => {
    const parent = dirname(path9);
    opts.recursive = false;
    if (parent === path9) {
      try {
        return opts.mkdirSync(path9, opts);
      } catch (er) {
        if (er.code !== "EISDIR")
          throw er;
        else
          return;
      }
    }
    try {
      opts.mkdirSync(path9, opts);
      return made || path9;
    } catch (er) {
      if (er.code === "ENOENT")
        return mkdirpManualSync(path9, opts, mkdirpManualSync(parent, opts, made));
      if (er.code !== "EEXIST" && er.code !== "EROFS")
        throw er;
      try {
        if (!opts.statSync(path9).isDirectory())
          throw er;
      } catch (_) {
        throw er;
      }
    }
  };
  module2.exports = {mkdirpManual, mkdirpManualSync};
});

// node_modules/mkdirp/lib/mkdirp-native.js
var require_mkdirp_native = __commonJS((exports2, module2) => {
  var {dirname} = require("path");
  var {findMade, findMadeSync} = require_find_made();
  var {mkdirpManual, mkdirpManualSync} = require_mkdirp_manual();
  var mkdirpNative = (path9, opts) => {
    opts.recursive = true;
    const parent = dirname(path9);
    if (parent === path9)
      return opts.mkdirAsync(path9, opts);
    return findMade(opts, path9).then((made) => opts.mkdirAsync(path9, opts).then(() => made).catch((er) => {
      if (er.code === "ENOENT")
        return mkdirpManual(path9, opts);
      else
        throw er;
    }));
  };
  var mkdirpNativeSync = (path9, opts) => {
    opts.recursive = true;
    const parent = dirname(path9);
    if (parent === path9)
      return opts.mkdirSync(path9, opts);
    const made = findMadeSync(opts, path9);
    try {
      opts.mkdirSync(path9, opts);
      return made;
    } catch (er) {
      if (er.code === "ENOENT")
        return mkdirpManualSync(path9, opts);
      else
        throw er;
    }
  };
  module2.exports = {mkdirpNative, mkdirpNativeSync};
});

// node_modules/mkdirp/lib/use-native.js
var require_use_native = __commonJS((exports2, module2) => {
  var fs7 = require("fs");
  var version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
  var versArr = version.replace(/^v/, "").split(".");
  var hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
  var useNative = !hasNative ? () => false : (opts) => opts.mkdir === fs7.mkdir;
  var useNativeSync = !hasNative ? () => false : (opts) => opts.mkdirSync === fs7.mkdirSync;
  module2.exports = {useNative, useNativeSync};
});

// node_modules/mkdirp/index.js
var require_mkdirp = __commonJS((exports2, module2) => {
  var optsArg = require_opts_arg();
  var pathArg = require_path_arg();
  var {mkdirpNative, mkdirpNativeSync} = require_mkdirp_native();
  var {mkdirpManual, mkdirpManualSync} = require_mkdirp_manual();
  var {useNative, useNativeSync} = require_use_native();
  var mkdirp2 = (path9, opts) => {
    path9 = pathArg(path9);
    opts = optsArg(opts);
    return useNative(opts) ? mkdirpNative(path9, opts) : mkdirpManual(path9, opts);
  };
  var mkdirpSync = (path9, opts) => {
    path9 = pathArg(path9);
    opts = optsArg(opts);
    return useNativeSync(opts) ? mkdirpNativeSync(path9, opts) : mkdirpManualSync(path9, opts);
  };
  mkdirp2.sync = mkdirpSync;
  mkdirp2.native = (path9, opts) => mkdirpNative(pathArg(path9), optsArg(opts));
  mkdirp2.manual = (path9, opts) => mkdirpManual(pathArg(path9), optsArg(opts));
  mkdirp2.nativeSync = (path9, opts) => mkdirpNativeSync(pathArg(path9), optsArg(opts));
  mkdirp2.manualSync = (path9, opts) => mkdirpManualSync(pathArg(path9), optsArg(opts));
  module2.exports = mkdirp2;
});

// src/index.ts
__export(exports, {
  activate: () => activate
});
var import_coc13 = __toModule(require("coc.nvim"));

// src/buffers.ts
var import_coc = __toModule(require("coc.nvim"));
var import_safe = __toModule(require_safe());
var regex = /^\s*(\d+)(.+?)"(.+?)".*/;
var BufferList = class extends import_coc.BasicList {
  constructor(nvim) {
    super(nvim);
    this.name = "buffers";
    this.defaultAction = "open";
    this.description = "get buffer list";
    this.addAction("open", async (item) => {
      let {bufnr} = item.data;
      await nvim.command(`buffer ${bufnr}`);
    });
    this.addAction("drop", async (item) => {
      let {bufnr, visible} = item.data;
      if (visible) {
        let info = await nvim.call("getbufinfo", bufnr);
        if (info.length && info[0].windows.length) {
          let winid = info[0].windows[0];
          await nvim.call("win_gotoid", winid);
          return;
        }
      }
      await nvim.command(`buffer ${bufnr}`);
    });
    this.addAction("split", async (item) => {
      let {bufnr} = item.data;
      await nvim.command(`sb ${bufnr}`);
    });
    this.addAction("tabe", async (item) => {
      let {bufname} = item.data;
      let escaped = await nvim.call("fnameescape", bufname);
      await nvim.command(`tabe ${escaped}`);
    });
    this.addAction("vsplit", async (item) => {
      let {bufname} = item.data;
      let escaped = await nvim.call("fnameescape", bufname);
      await nvim.command(`vs ${escaped}`);
    });
    this.addAction("delete", async (item) => {
      let {bufnr} = item.data;
      await nvim.command(`bdelete ${bufnr}`);
    }, {persist: true, reload: true});
    this.addAction("wipe", async (item) => {
      let {bufnr} = item.data;
      await nvim.command(`bwipeout ${bufnr}`);
    }, {persist: true, reload: true});
    this.addAction("preview", async (item, context) => {
      let {nvim: nvim2} = this;
      let {bufname, bufnr} = item.data;
      let lines = await nvim2.call("getbufline", [bufnr, 1, 200]);
      let filetype = await nvim2.call("getbufvar", [bufnr, "&filetype", "txt"]);
      if (lines.length == 0) {
        lines = [`Unable to get lines for buffer ${bufname}, add 'set hidden' in your vimrc.`];
      }
      await this.preview({
        filetype,
        bufname,
        lines,
        sketch: true
      }, context);
    });
  }
  async loadItems(_context) {
    const {nvim} = this;
    const bufnrAlt = Number(await nvim.call("bufnr", "#"));
    const content = await nvim.call("execute", "ls");
    return content.split(/\n/).reduce((res, line) => {
      const ms = line.match(regex);
      if (!ms)
        return res;
      const bufnr = Number(ms[1]);
      const item = {
        label: ` ${import_safe.default.magenta(ms[1])}${import_safe.default.america(ms[2])}${ms[3]}`,
        filterText: ms[3],
        sortText: ms[1],
        data: {
          bufnr,
          bufname: ms[3],
          visible: ms[2].indexOf("a") !== -1
        }
      };
      return bufnr === bufnrAlt ? [item, ...res] : [...res, item];
    }, []);
  }
};
var buffers_default = BufferList;

// src/changes.ts
var import_safe2 = __toModule(require_safe());
var regex2 = /^[^\d]*(\d+)[^\d]+(\d+)[^\d]+(\d+)[^\w]+(.*)$/;
var ChangeList = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.name = "changes";
    this.description = "changes list";
    this.defaultAction = "jump";
    this.actions = [];
    this.actions.push({
      name: "jump",
      execute: (item) => {
        if (Array.isArray(item))
          return;
        nvim.command(`normal! ${item.data.lnum}G${item.data.col}|zz`, true);
      }
    });
  }
  async loadItems(_context) {
    const {nvim} = this;
    let list = await nvim.eval('split(execute("changes"), "\n")');
    list = list.slice(1);
    list = list.filter((s) => regex2.test(s));
    return list.map((line) => {
      let [, change, lnum, col, text] = line.match(regex2);
      return {
        label: `${import_safe2.default.magenta(change)}	${import_safe2.default.grey(lnum)}	${import_safe2.default.grey(col)}	${text}`,
        filterText: text,
        data: {lnum, col}
      };
    });
  }
};
var changes_default = ChangeList;

// src/cmdhistory.ts
var regex3 = /^\s*\d+\s+(.*)$/;
var Cmdhistory = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.name = "cmdhistory";
    this.description = "history of vim commands";
    this.defaultAction = "execute";
    this.actions = [];
    this.actions.push({
      name: "execute",
      execute: async (item) => {
        if (Array.isArray(item))
          return;
        nvim.command(item.data.cmd, true);
      }
    });
  }
  async loadItems(_context) {
    let {nvim} = this;
    let list = await nvim.eval(`split(execute("history cmd"),"
")`);
    list = list.slice(1);
    let res = [];
    for (let line of list) {
      let ms = line.match(regex3);
      if (ms) {
        let [, cmd] = ms;
        res.push({
          label: cmd,
          filterText: cmd,
          data: {
            cmd
          }
        });
      }
    }
    return res;
  }
};
var cmdhistory_default = Cmdhistory;

// src/colors.ts
var import_coc2 = __toModule(require("coc.nvim"));
var import_path = __toModule(require("path"));
var Colors = class extends import_coc2.BasicList {
  constructor(nvim) {
    super(nvim);
    this.name = "colors";
    this.description = "color schemes";
    this.defaultAction = "set";
    this.actions = [];
    this.addLocationActions();
    this.addAction("set", (item) => {
      if (Array.isArray(item))
        return;
      nvim.command(`colorscheme ${item.data.name}`, true);
    });
  }
  async loadItems(_context) {
    let {nvim} = this;
    let colors10 = await nvim.eval('split(globpath(&rtp, "colors/*.vim"),"\n")');
    let hasPackages = await nvim.call("has", ["packages"]);
    if (hasPackages) {
      let packageColors = await nvim.eval('split(globpath(&packpath, "pack/*/opt/*/colors/*.vim"),"\n")');
      colors10.push(...packageColors);
    }
    return colors10.map((file) => {
      let name = import_path.default.basename(file, ".vim");
      return {
        label: `${name}	${file}`,
        filterText: name,
        data: {name},
        location: import_coc2.Uri.file(file).toString()
      };
    });
  }
  doHighlight() {
    let {nvim} = this;
    nvim.pauseNotification();
    nvim.command("syntax match CocColorsName /\\v^[^\\t]+/ contained containedin=CocColorsLine", true);
    nvim.command("syntax match CocColorsFile /\\t.*$/ contained containedin=CocColorsLine", true);
    nvim.command("highlight default link CocColorsName Identifier", true);
    nvim.command("highlight default link CocColorsFile Comment", true);
    nvim.resumeNotification(false, true);
  }
};
var colors_default = Colors;

// src/commands.ts
var import_safe3 = __toModule(require_safe());
var import_fs = __toModule(require("fs"));
var import_util = __toModule(require("util"));

// src/util/index.ts
var import_which = __toModule(require_which());
var import_path2 = __toModule(require("path"));
function executable(cmd) {
  try {
    import_which.default.sync(cmd);
  } catch (e) {
    return false;
  }
  return true;
}
function characterIndex(content, byteIndex2) {
  let buf = Buffer.from(content, "utf8");
  return buf.slice(0, byteIndex2).toString("utf8").length;
}
function wait(ms) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(void 0);
    }, ms);
  });
}
function pad(n, total) {
  let l = total - n.length;
  if (l <= 0)
    return "";
  return new Array(l).fill(" ").join("");
}
function distinct(array, keyFn) {
  if (!keyFn) {
    return array.filter((element, position) => {
      return array.indexOf(element) === position;
    });
  }
  const seen = Object.create(null);
  return array.filter((elem) => {
    const key = keyFn(elem);
    if (seen[key]) {
      return false;
    }
    seen[key] = true;
    return true;
  });
}
function isParentFolder(folder, filepath) {
  let rel = import_path2.default.relative(folder, filepath);
  return !rel.startsWith("..");
}

// src/commands.ts
var regex4 = /^\|:(\S+)\|\t(\S+)\t(.*)$/;
var Commands = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.name = "vimcommands";
    this.description = "command list";
    this.defaultAction = "execute";
    this.actions = [];
    this.actions.push({
      name: "execute",
      execute: async (item) => {
        if (Array.isArray(item))
          return;
        let {command, shabang, hasArgs} = item.data;
        if (!hasArgs) {
          nvim.command(command, true);
        } else {
          const feedableCommand = `:${command}${shabang ? "" : " "}`;
          const mode = await nvim.call("mode");
          const isInsertMode = mode.startsWith("i");
          if (isInsertMode) {
            nvim.command(`call feedkeys("\\<C-O>${feedableCommand}", 'n')`, true);
          } else {
            await nvim.feedKeys(feedableCommand, "n", true);
          }
        }
      }
    });
    this.actions.push({
      name: "open",
      execute: async (item) => {
        if (Array.isArray(item))
          return;
        let {command} = item.data;
        if (!/^[A-Z]/.test(command))
          return;
        let res = await nvim.eval(`split(execute("verbose command ${command}"),"
")[-1]`);
        if (/Last\sset\sfrom/.test(res)) {
          let filepath = res.replace(/^\s+Last\sset\sfrom\s+/, "");
          nvim.command(`edit +/${command} ${filepath}`, true);
        }
      }
    });
  }
  async loadItems(_context) {
    let {nvim} = this;
    let list = await nvim.eval('split(execute("command"),"\n")');
    list = list.slice(1);
    let res = [];
    for (let str of list) {
      let name = str.slice(4).match(/\S+/)[0];
      let end = str.slice(4 + name.length);
      res.push({
        label: str.slice(0, 4) + import_safe3.default.magenta(name) + end,
        filterText: name,
        data: {
          command: name,
          shabang: str.startsWith("!"),
          hasArgs: !end.match(/^\s*0\s/)
        }
      });
    }
    let help = await nvim.eval(`globpath($VIMRUNTIME, 'doc/index.txt')`);
    if (help && import_fs.default.existsSync(help)) {
      let content = await import_util.default.promisify(import_fs.default.readFile)(help, "utf8");
      for (let line of content.split(/\r?\n/)) {
        let ms = line.match(regex4);
        if (ms) {
          let [, cmd, chars, description] = ms;
          res.push({
            label: `    ${import_safe3.default.magenta(cmd)}${pad(cmd, 20)}${chars}${pad(chars, 30)}${description}`,
            filterText: cmd,
            data: {
              command: cmd,
              shabang: false,
              hasArgs: true
            }
          });
        }
      }
    }
    return res;
  }
};
var commands_default = Commands;

// src/files.ts
var import_child_process = __toModule(require("child_process"));
var import_coc3 = __toModule(require("coc.nvim"));
var import_events = __toModule(require("events"));
var import_fs2 = __toModule(require("fs"));
var import_minimatch = __toModule(require_minimatch());
var import_path3 = __toModule(require("path"));
var import_readline = __toModule(require("readline"));
var Task = class extends import_events.EventEmitter {
  constructor() {
    super(...arguments);
    this.processes = [];
  }
  start(cmd, args, cwds, patterns) {
    let remain = cwds.length;
    for (let cwd of cwds) {
      let process2 = import_child_process.spawn(cmd, args, {cwd});
      this.processes.push(process2);
      process2.on("error", (e) => {
        this.emit("error", e.message);
      });
      const rl = import_readline.default.createInterface(process2.stdout);
      const range = import_coc3.Range.create(0, 0, 0, 0);
      let hasPattern = patterns.length > 0;
      process2.stderr.on("data", (chunk) => {
        console.error(chunk.toString("utf8"));
      });
      rl.on("line", (line) => {
        let file = line;
        if (file.indexOf(cwd) < 0) {
          file = import_path3.default.join(cwd, line);
        }
        if (hasPattern && patterns.some((p) => import_minimatch.default(file, p)))
          return;
        let location = import_coc3.Location.create(import_coc3.Uri.file(file).toString(), range);
        this.emit("data", {
          label: line,
          sortText: file,
          location
        });
      });
      rl.on("close", () => {
        remain = remain - 1;
        if (remain == 0) {
          this.emit("end");
        }
      });
    }
  }
  dispose() {
    for (let process2 of this.processes) {
      if (!process2.killed) {
        process2.kill();
      }
    }
  }
};
var FilesList = class extends import_coc3.BasicList {
  constructor(nvim) {
    super(nvim);
    this.name = "files";
    this.defaultAction = "open";
    this.description = "Search files by rg or ag";
    this.detail = `Install ripgrep in your $PATH to have best experience.
Files is searched from current cwd by default.
Provide directory names as arguments to search other directories.
Use 'list.source.files.command' configuration for custom search command.
Use 'list.source.files.args' configuration for custom command arguments.
Note that rg ignore hidden files by default.`;
    this.options = [{
      name: "-F, -folder",
      description: "Search files from current workspace folder instead of cwd."
    }, {
      name: "-W, -workspace",
      description: "Search files from all workspace folders instead of cwd."
    }];
    this.addLocationActions();
  }
  getArgs(args, defaultArgs) {
    return args.length ? args : defaultArgs;
  }
  getCommand() {
    let config = import_coc3.workspace.getConfiguration("list.source.files");
    let cmd = config.get("command", "");
    let args = config.get("args", []);
    if (!cmd) {
      if (executable("rg")) {
        return {cmd: "rg", args: this.getArgs(args, ["--color", "never", "--files"])};
      } else if (executable("ag")) {
        return {cmd: "ag", args: this.getArgs(args, ["-f", "-g", ".", "--nocolor"])};
      } else if (process.platform == "win32") {
        return {cmd: "dir", args: this.getArgs(args, ["/a-D", "/S", "/B"])};
      } else if (executable("find")) {
        return {cmd: "find", args: this.getArgs(args, [".", "-type", "f"])};
      } else {
        throw new Error("Unable to find command for files list.");
        return null;
      }
    } else {
      return {cmd, args};
    }
  }
  async loadItems(context) {
    let {nvim} = this;
    let {window: window3, args} = context;
    let options2 = this.parseArguments(args);
    let res = this.getCommand();
    if (!res)
      return null;
    let used = res.args.concat(["-F", "-folder", "-W", "-workspace"]);
    let extraArgs = args.filter((s) => used.indexOf(s) == -1);
    let cwds;
    let dirArgs = [];
    let searchArgs = [];
    if (options2.folder) {
      cwds = [import_coc3.workspace.rootPath];
    } else if (options2.workspace) {
      cwds = import_coc3.workspace.workspaceFolders.map((f) => import_coc3.Uri.parse(f.uri).fsPath);
    } else {
      if (extraArgs.length > 0) {
        for (let i = 0; i < extraArgs.length; i++) {
          let d = await nvim.call("expand", extraArgs[i]);
          try {
            if (import_fs2.default.lstatSync(d).isDirectory()) {
              dirArgs.push(d);
            } else {
              searchArgs.push(d);
            }
          } catch (e) {
            searchArgs.push(d);
          }
        }
      }
      if (dirArgs.length > 0) {
        cwds = dirArgs;
      } else {
        let valid = await window3.valid;
        if (valid) {
          cwds = [await nvim.call("getcwd", window3.id)];
        } else {
          cwds = [await nvim.call("getcwd")];
        }
      }
    }
    let task = new Task();
    let excludePatterns = this.getConfig().get("excludePatterns", []);
    task.start(res.cmd, res.args.concat(searchArgs), cwds, excludePatterns);
    return task;
  }
};
var files_default = FilesList;

// src/filetypes.ts
var Filetypes = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.name = "filetypes";
    this.description = "available filetypes";
    this.defaultAction = "set";
    this.actions = [];
    this.actions.push({
      name: "set",
      execute: (item) => {
        if (Array.isArray(item)) {
          for (let i of item) {
            nvim.command(`setf ${i.label}`, true);
          }
        } else {
          nvim.command(`setf ${item.label}`, true);
        }
      }
    });
  }
  async loadItems(_context) {
    let {nvim} = this;
    let filetypes = await nvim.eval(`sort(map(split(globpath(&rtp, 'syntax/*.vim'), '
'),'fnamemodify(v:val, ":t:r")'))`);
    filetypes = distinct(filetypes);
    return filetypes.map((filetype) => {
      return {label: filetype};
    });
  }
};
var filetypes_default = Filetypes;

// src/grep.ts
var import_child_process2 = __toModule(require("child_process"));
var import_coc4 = __toModule(require("coc.nvim"));
var import_events2 = __toModule(require("events"));
var import_minimatch2 = __toModule(require_minimatch());
var import_path4 = __toModule(require("path"));
var import_readline2 = __toModule(require("readline"));

// node_modules/vscode-uri/lib/esm/index.js
"use strict";
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var _a;
var isWindows;
if (typeof process === "object") {
  isWindows = process.platform === "win32";
} else if (typeof navigator === "object") {
  userAgent = navigator.userAgent;
  isWindows = userAgent.indexOf("Windows") >= 0;
}
var userAgent;
var _schemePattern = /^\w[\w\d+.-]*$/;
var _singleSlashStart = /^\//;
var _doubleSlashStart = /^\/\//;
function _validateUri(ret, _strict) {
  if (!ret.scheme && _strict) {
    throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "' + ret.authority + '", path: "' + ret.path + '", query: "' + ret.query + '", fragment: "' + ret.fragment + '"}');
  }
  if (ret.scheme && !_schemePattern.test(ret.scheme)) {
    throw new Error("[UriError]: Scheme contains illegal characters.");
  }
  if (ret.path) {
    if (ret.authority) {
      if (!_singleSlashStart.test(ret.path)) {
        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
      }
    } else {
      if (_doubleSlashStart.test(ret.path)) {
        throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
      }
    }
  }
}
function _schemeFix(scheme, _strict) {
  if (!scheme && !_strict) {
    return "file";
  }
  return scheme;
}
function _referenceResolution(scheme, path9) {
  switch (scheme) {
    case "https":
    case "http":
    case "file":
      if (!path9) {
        path9 = _slash;
      } else if (path9[0] !== _slash) {
        path9 = _slash + path9;
      }
      break;
  }
  return path9;
}
var _empty = "";
var _slash = "/";
var _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
var URI = function() {
  function URI2(schemeOrData, authority, path9, query, fragment, _strict) {
    if (_strict === void 0) {
      _strict = false;
    }
    if (typeof schemeOrData === "object") {
      this.scheme = schemeOrData.scheme || _empty;
      this.authority = schemeOrData.authority || _empty;
      this.path = schemeOrData.path || _empty;
      this.query = schemeOrData.query || _empty;
      this.fragment = schemeOrData.fragment || _empty;
    } else {
      this.scheme = _schemeFix(schemeOrData, _strict);
      this.authority = authority || _empty;
      this.path = _referenceResolution(this.scheme, path9 || _empty);
      this.query = query || _empty;
      this.fragment = fragment || _empty;
      _validateUri(this, _strict);
    }
  }
  URI2.isUri = function(thing) {
    if (thing instanceof URI2) {
      return true;
    }
    if (!thing) {
      return false;
    }
    return typeof thing.authority === "string" && typeof thing.fragment === "string" && typeof thing.path === "string" && typeof thing.query === "string" && typeof thing.scheme === "string" && typeof thing.fsPath === "function" && typeof thing.with === "function" && typeof thing.toString === "function";
  };
  Object.defineProperty(URI2.prototype, "fsPath", {
    get: function() {
      return uriToFsPath(this, false);
    },
    enumerable: true,
    configurable: true
  });
  URI2.prototype.with = function(change) {
    if (!change) {
      return this;
    }
    var scheme = change.scheme, authority = change.authority, path9 = change.path, query = change.query, fragment = change.fragment;
    if (scheme === void 0) {
      scheme = this.scheme;
    } else if (scheme === null) {
      scheme = _empty;
    }
    if (authority === void 0) {
      authority = this.authority;
    } else if (authority === null) {
      authority = _empty;
    }
    if (path9 === void 0) {
      path9 = this.path;
    } else if (path9 === null) {
      path9 = _empty;
    }
    if (query === void 0) {
      query = this.query;
    } else if (query === null) {
      query = _empty;
    }
    if (fragment === void 0) {
      fragment = this.fragment;
    } else if (fragment === null) {
      fragment = _empty;
    }
    if (scheme === this.scheme && authority === this.authority && path9 === this.path && query === this.query && fragment === this.fragment) {
      return this;
    }
    return new _URI(scheme, authority, path9, query, fragment);
  };
  URI2.parse = function(value, _strict) {
    if (_strict === void 0) {
      _strict = false;
    }
    var match = _regexp.exec(value);
    if (!match) {
      return new _URI(_empty, _empty, _empty, _empty, _empty);
    }
    return new _URI(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);
  };
  URI2.file = function(path9) {
    var authority = _empty;
    if (isWindows) {
      path9 = path9.replace(/\\/g, _slash);
    }
    if (path9[0] === _slash && path9[1] === _slash) {
      var idx = path9.indexOf(_slash, 2);
      if (idx === -1) {
        authority = path9.substring(2);
        path9 = _slash;
      } else {
        authority = path9.substring(2, idx);
        path9 = path9.substring(idx) || _slash;
      }
    }
    return new _URI("file", authority, path9, _empty, _empty);
  };
  URI2.from = function(components) {
    return new _URI(components.scheme, components.authority, components.path, components.query, components.fragment);
  };
  URI2.prototype.toString = function(skipEncoding) {
    if (skipEncoding === void 0) {
      skipEncoding = false;
    }
    return _asFormatted(this, skipEncoding);
  };
  URI2.prototype.toJSON = function() {
    return this;
  };
  URI2.revive = function(data) {
    if (!data) {
      return data;
    } else if (data instanceof URI2) {
      return data;
    } else {
      var result = new _URI(data);
      result._formatted = data.external;
      result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;
      return result;
    }
  };
  return URI2;
}();
var _pathSepMarker = isWindows ? 1 : void 0;
var _URI = function(_super) {
  __extends(_URI2, _super);
  function _URI2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._formatted = null;
    _this._fsPath = null;
    return _this;
  }
  Object.defineProperty(_URI2.prototype, "fsPath", {
    get: function() {
      if (!this._fsPath) {
        this._fsPath = uriToFsPath(this, false);
      }
      return this._fsPath;
    },
    enumerable: true,
    configurable: true
  });
  _URI2.prototype.toString = function(skipEncoding) {
    if (skipEncoding === void 0) {
      skipEncoding = false;
    }
    if (!skipEncoding) {
      if (!this._formatted) {
        this._formatted = _asFormatted(this, false);
      }
      return this._formatted;
    } else {
      return _asFormatted(this, true);
    }
  };
  _URI2.prototype.toJSON = function() {
    var res = {
      $mid: 1
    };
    if (this._fsPath) {
      res.fsPath = this._fsPath;
      res._sep = _pathSepMarker;
    }
    if (this._formatted) {
      res.external = this._formatted;
    }
    if (this.path) {
      res.path = this.path;
    }
    if (this.scheme) {
      res.scheme = this.scheme;
    }
    if (this.authority) {
      res.authority = this.authority;
    }
    if (this.query) {
      res.query = this.query;
    }
    if (this.fragment) {
      res.fragment = this.fragment;
    }
    return res;
  };
  return _URI2;
}(URI);
var encodeTable = (_a = {}, _a[58] = "%3A", _a[47] = "%2F", _a[63] = "%3F", _a[35] = "%23", _a[91] = "%5B", _a[93] = "%5D", _a[64] = "%40", _a[33] = "%21", _a[36] = "%24", _a[38] = "%26", _a[39] = "%27", _a[40] = "%28", _a[41] = "%29", _a[42] = "%2A", _a[43] = "%2B", _a[44] = "%2C", _a[59] = "%3B", _a[61] = "%3D", _a[32] = "%20", _a);
function encodeURIComponentFast(uriComponent, allowSlash) {
  var res = void 0;
  var nativeEncodePos = -1;
  for (var pos = 0; pos < uriComponent.length; pos++) {
    var code = uriComponent.charCodeAt(pos);
    if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 46 || code === 95 || code === 126 || allowSlash && code === 47) {
      if (nativeEncodePos !== -1) {
        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
        nativeEncodePos = -1;
      }
      if (res !== void 0) {
        res += uriComponent.charAt(pos);
      }
    } else {
      if (res === void 0) {
        res = uriComponent.substr(0, pos);
      }
      var escaped = encodeTable[code];
      if (escaped !== void 0) {
        if (nativeEncodePos !== -1) {
          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
          nativeEncodePos = -1;
        }
        res += escaped;
      } else if (nativeEncodePos === -1) {
        nativeEncodePos = pos;
      }
    }
  }
  if (nativeEncodePos !== -1) {
    res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
  }
  return res !== void 0 ? res : uriComponent;
}
function encodeURIComponentMinimal(path9) {
  var res = void 0;
  for (var pos = 0; pos < path9.length; pos++) {
    var code = path9.charCodeAt(pos);
    if (code === 35 || code === 63) {
      if (res === void 0) {
        res = path9.substr(0, pos);
      }
      res += encodeTable[code];
    } else {
      if (res !== void 0) {
        res += path9[pos];
      }
    }
  }
  return res !== void 0 ? res : path9;
}
function uriToFsPath(uri, keepDriveLetterCasing) {
  var value;
  if (uri.authority && uri.path.length > 1 && uri.scheme === "file") {
    value = "//" + uri.authority + uri.path;
  } else if (uri.path.charCodeAt(0) === 47 && (uri.path.charCodeAt(1) >= 65 && uri.path.charCodeAt(1) <= 90 || uri.path.charCodeAt(1) >= 97 && uri.path.charCodeAt(1) <= 122) && uri.path.charCodeAt(2) === 58) {
    if (!keepDriveLetterCasing) {
      value = uri.path[1].toLowerCase() + uri.path.substr(2);
    } else {
      value = uri.path.substr(1);
    }
  } else {
    value = uri.path;
  }
  if (isWindows) {
    value = value.replace(/\//g, "\\");
  }
  return value;
}
function _asFormatted(uri, skipEncoding) {
  var encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;
  var res = "";
  var scheme = uri.scheme, authority = uri.authority, path9 = uri.path, query = uri.query, fragment = uri.fragment;
  if (scheme) {
    res += scheme;
    res += ":";
  }
  if (authority || scheme === "file") {
    res += _slash;
    res += _slash;
  }
  if (authority) {
    var idx = authority.indexOf("@");
    if (idx !== -1) {
      var userinfo = authority.substr(0, idx);
      authority = authority.substr(idx + 1);
      idx = userinfo.indexOf(":");
      if (idx === -1) {
        res += encoder(userinfo, false);
      } else {
        res += encoder(userinfo.substr(0, idx), false);
        res += ":";
        res += encoder(userinfo.substr(idx + 1), false);
      }
      res += "@";
    }
    authority = authority.toLowerCase();
    idx = authority.indexOf(":");
    if (idx === -1) {
      res += encoder(authority, false);
    } else {
      res += encoder(authority.substr(0, idx), false);
      res += authority.substr(idx);
    }
  }
  if (path9) {
    if (path9.length >= 3 && path9.charCodeAt(0) === 47 && path9.charCodeAt(2) === 58) {
      var code = path9.charCodeAt(1);
      if (code >= 65 && code <= 90) {
        path9 = "/" + String.fromCharCode(code + 32) + ":" + path9.substr(3);
      }
    } else if (path9.length >= 2 && path9.charCodeAt(1) === 58) {
      var code = path9.charCodeAt(0);
      if (code >= 65 && code <= 90) {
        path9 = String.fromCharCode(code + 32) + ":" + path9.substr(2);
      }
    }
    res += encoder(path9, true);
  }
  if (query) {
    res += "?";
    res += encoder(query, false);
  }
  if (fragment) {
    res += "#";
    res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;
  }
  return res;
}
function decodeURIComponentGraceful(str) {
  try {
    return decodeURIComponent(str);
  } catch (_a2) {
    if (str.length > 3) {
      return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
    } else {
      return str;
    }
  }
}
var _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
function percentDecode(str) {
  if (!str.match(_rEncodedAsHex)) {
    return str;
  }
  return str.replace(_rEncodedAsHex, function(match) {
    return decodeURIComponentGraceful(match);
  });
}

// src/util/ansiparse.ts
var foregroundColors = {
  30: "black",
  31: "red",
  32: "green",
  33: "yellow",
  34: "blue",
  35: "magenta",
  36: "cyan",
  37: "white",
  90: "grey"
};
var backgroundColors = {
  40: "black",
  41: "red",
  42: "green",
  43: "yellow",
  44: "blue",
  45: "magenta",
  46: "cyan",
  47: "white"
};
var styles = {
  1: "bold",
  3: "italic",
  4: "underline"
};
function ansiparse(str) {
  let matchingControl = null;
  let matchingData = null;
  let matchingText = "";
  let ansiState = [];
  let result = [];
  let state = {};
  let eraseChar;
  eraseChar = () => {
    let index;
    let text;
    if (matchingText.length) {
      matchingText = matchingText.substr(0, matchingText.length - 1);
    } else if (result.length) {
      index = result.length - 1;
      text = result[index].text;
      if (text.length === 1) {
        result.pop();
      } else {
        result[index].text = text.substr(0, text.length - 1);
      }
    }
  };
  for (let i = 0; i < str.length; i++) {
    if (matchingControl != null) {
      if (matchingControl == "" && str[i] == "[") {
        if (matchingText) {
          state.text = matchingText;
          result.push(state);
          state = {};
          matchingText = "";
        }
        matchingControl = null;
        matchingData = "";
      } else {
        matchingText += matchingControl + str[i];
        matchingControl = null;
      }
      continue;
    } else if (matchingData != null) {
      if (str[i] == ";") {
        ansiState.push(matchingData);
        matchingData = "";
      } else if (str[i] == "m" || str[i] == "K") {
        ansiState.push(matchingData);
        matchingData = null;
        matchingText = "";
        ansiState.forEach((ansiCode) => {
          if (foregroundColors[ansiCode]) {
            state.foreground = foregroundColors[ansiCode];
          } else if (backgroundColors[ansiCode]) {
            state.background = backgroundColors[ansiCode];
          } else if (ansiCode == 39) {
            delete state.foreground;
          } else if (ansiCode == 49) {
            delete state.background;
          } else if (styles[ansiCode]) {
            state[styles[ansiCode]] = true;
          } else if (ansiCode == 22) {
            state.bold = false;
          } else if (ansiCode == 23) {
            state.italic = false;
          } else if (ansiCode == 24) {
            state.underline = false;
          }
        });
        ansiState = [];
      } else {
        matchingData += str[i];
      }
      continue;
    }
    if (str[i] == "") {
      matchingControl = str[i];
    } else if (str[i] == "\b") {
      eraseChar();
    } else {
      matchingText += str[i];
    }
  }
  if (matchingText) {
    state.text = matchingText + (matchingControl ? matchingControl : "");
    result.push(state);
  }
  return result;
}

// src/util/option.ts
var options = [];
function defineOptions(s, l, ag, rg) {
  options.push([s, l, ag, rg]);
}
defineOptions("-S", "-smartcase", "--smart-case", "--smart-case");
defineOptions("-i", "-ignorecase", "--ignore-case", "--ignore-case");
defineOptions("-l", "-literal", "--fixed-strings", "--fixed-strings");
defineOptions("-w", "-word", "--word-regexp", "--word-regexp");
defineOptions("-e", "-regex", "", "--regexp");
defineOptions("-u", "-skip-vcs-ignores", "--skip-vcs-ignores", "--no-ignore-vcs");
defineOptions("-t", "-extension", null, null);
function getOption(opt, command) {
  let idx = opt.length == 2 ? 0 : 1;
  let o = options.find((o2) => o2[idx] == opt);
  if (!o)
    return opt;
  return command === "ag" ? o[2] : o[3];
}
function convertOptions(list, command, defaultLiteral = false) {
  let useLiteral = defaultLiteral && list.find((o) => {
    return ["-e", "-regex", "-w", "-word", "-l", "-literal"].indexOf(o) != -1;
  }) == null;
  let res = [];
  if (useLiteral)
    list.unshift("-l");
  for (let idx = 0; idx < list.length; idx++) {
    let s = list[idx];
    if (/^-/.test(s)) {
      if (s === "-t" || s === "-extension") {
        let f = list[idx + 1];
        if (!f || /^-/.test(f))
          continue;
        if (command == "rg") {
          res.push("--glob", `*.${f}`);
        } else {
          res.push("-G", `*.${f}`);
        }
        idx++;
      } else {
        res.push(getOption(s, command));
      }
    } else {
      res.push(s);
    }
  }
  if (command === "ag" && list.indexOf("-S") === -1 && list.indexOf("-smartcase") === -1) {
    res.unshift("-s");
  }
  return res;
}

// src/grep.ts
var lineRegex = /^(.+):(\d+):(\d+):(.*)/;
var controlCode = "";
var Task2 = class extends import_events2.EventEmitter {
  constructor(interactive) {
    super();
    this.interactive = interactive;
    this.processes = [];
  }
  start(cmd, args, cwds, patterns) {
    for (let cwd of cwds) {
      let remain = cwds.length;
      let process2 = import_child_process2.spawn(cmd, args, {cwd});
      process2.on("error", (e) => {
        this.emit("error", e.message);
      });
      process2.stderr.on("data", (chunk) => {
        let parts = ansiparse(chunk.toString("utf8"));
        let escaped = parts.reduce((s, curr) => s + curr.text, "");
        console.error(escaped);
      });
      const rl = import_readline2.default.createInterface(process2.stdout);
      let hasPattern = patterns.length > 0;
      rl.on("line", (line) => {
        let ms;
        let escaped;
        if (line.indexOf(controlCode) !== -1) {
          let parts = ansiparse(line);
          escaped = parts.reduce((s, curr) => s + curr.text, "");
          ms = escaped.match(lineRegex);
        } else {
          ms = line.match(lineRegex);
          escaped = line;
        }
        if (!ms)
          return;
        let file = import_path4.default.join(cwd, ms[1]);
        if (hasPattern && patterns.some((p) => import_minimatch2.default(file, p)))
          return;
        let pos = import_coc4.Position.create(Number(ms[2]) - 1, byteSlice(ms[4], 0, Number(ms[3]) - 1).length);
        let location = import_coc4.Location.create(URI.file(file).toString(), import_coc4.Range.create(pos, pos));
        this.emit("data", {
          label: line,
          filterText: this.interactive ? "" : escaped,
          location
        });
      });
      rl.on("close", () => {
        remain = remain - 1;
        if (remain == 0) {
          this.emit("end");
        }
      });
    }
  }
  dispose() {
    for (let process2 of this.processes) {
      if (!process2.killed) {
        process2.kill();
      }
    }
  }
};
var GrepList = class extends import_coc4.BasicList {
  constructor(nvim) {
    super(nvim);
    this.interactive = true;
    this.description = "grep text by rg or ag";
    this.name = "grep";
    this.defaultAction = "open";
    this.detail = `Literal match is used by default.
To use interactive mode, add '-I' or '--interactive' to LIST OPTIONS.
To change colors, checkout 'man rg' or 'man ag'.
To search from workspace folders instead of cwd, use '-folder' or '-workspace' argument.
Grep source provide some uniformed options to ease differences between rg and ag.`;
    this.options = [{
      name: "-S, -smartcase",
      description: "Use smartcase match."
    }, {
      name: "-i, -ignorecase",
      description: "Use ignorecase match."
    }, {
      name: "-l, -literal",
      description: "Treat the pattern as a literal string, used when -regex is not used."
    }, {
      name: "-w, -word",
      description: "Use word match."
    }, {
      name: "-e, -regex",
      description: "Use regex match."
    }, {
      name: "-u, -skip-vcs-ignores",
      description: "Don't respect version control ignore files(.gitignore, etc.)"
    }, {
      name: "-t, -extension EXTENSION",
      description: "Grep files with specified extension only, could be used multiple times.",
      hasValue: true
    }, {
      name: "-F, -folder",
      description: "Grep files from current workspace folder instead of cwd."
    }, {
      name: "-W, -workspace",
      description: "Grep files from all workspace folders instead of cwd."
    }];
    this.addLocationActions();
  }
  async loadItems(context) {
    let {nvim} = this;
    let {interactive} = context.options;
    let config = import_coc4.workspace.getConfiguration("list.source.grep");
    let cmd = config.get("command", "rg");
    let args = config.get("args", []).slice();
    let useLiteral = config.get("useLiteral", true);
    if (cmd == "rg") {
      let maxColumns = config.get("maxColumns", 300);
      args.push("--color", "always", "--max-columns", maxColumns.toString(), "--vimgrep");
    } else if (cmd == "ag") {
      args.push("--color", "--vimgrep");
    }
    if (!executable(cmd))
      throw new Error(`Command '${cmd}' not found on $PATH`);
    if (interactive && !context.input)
      return [];
    args.push(...context.args);
    if (context.input) {
      if (interactive && context.input.indexOf(" ") != -1) {
        let input = context.input.split(/\s+/).join(".*");
        if (!args.includes("-regex") && !args.includes("-e")) {
          args.push("-regex");
        }
        args.push(input);
      } else {
        args.push(context.input);
      }
    }
    let patterns = config.get("excludePatterns", []);
    let {window: window3} = context;
    let cwds;
    if (args.indexOf("-F") != -1 || args.indexOf("-folder") != -1) {
      cwds = [import_coc4.workspace.rootPath];
    } else if (args.indexOf("-W") != -1 || args.indexOf("-workspace") != -1) {
      cwds = import_coc4.workspace.workspaceFolders.map((f) => URI.parse(f.uri).fsPath);
    } else {
      let valid = await window3.valid;
      if (valid) {
        cwds = [await nvim.call("getcwd", window3.id)];
      } else {
        cwds = [await nvim.call("getcwd")];
      }
    }
    let task = new Task2(interactive);
    if (cmd == "rg" || cmd == "ag") {
      args = convertOptions(args, cmd, useLiteral);
      args = args.filter((s) => ["-F", "-folder", "-W", "-workspace"].indexOf(s) == -1);
    }
    args.push("--", "./");
    task.start(cmd, args, cwds, patterns);
    return task;
  }
};
var grep_default = GrepList;
function byteSlice(content, start, end) {
  let buf = Buffer.from(content, "utf8");
  return buf.slice(start, end).toString("utf8");
}

// src/helptags.ts
var import_coc5 = __toModule(require("coc.nvim"));
var import_fs3 = __toModule(require("fs"));
var import_path5 = __toModule(require("path"));
var Helptags = class extends import_coc5.BasicList {
  constructor(nvim) {
    super(nvim);
    this.name = "helptags";
    this.description = "helptags of vim";
    this.defaultAction = "show";
    this.addAction("show", (item) => {
      nvim.command(`help ${item.data.name}`, true);
    });
    this.addLocationActions();
  }
  async loadItems(_context) {
    let rtp = import_coc5.workspace.env.runtimepath;
    if (!rtp)
      return [];
    let folders = rtp.split(",");
    let result = [];
    let cwd = await this.nvim.call("getcwd");
    await Promise.all(folders.map((folder) => {
      return new Promise((resolve) => {
        let file = import_path5.default.join(folder, "doc/tags");
        import_fs3.default.readFile(file, "utf8", (err, content) => {
          if (err)
            return resolve();
          let lines = content.split(/\r?\n/);
          for (let line of lines) {
            if (line) {
              let [name, filepath, regex9] = line.split("	");
              let fullpath = import_path5.default.join(folder, "doc", filepath);
              let uri = URI.file(fullpath).toString();
              let file2 = isParentFolder(cwd, fullpath) ? import_path5.default.relative(cwd, fullpath) : fullpath;
              result.push({
                label: `${name}	${file2}`,
                filterText: name,
                location: {
                  uri,
                  line: regex9.replace(/^\//, "").replace(/\$\//, ""),
                  text: name
                },
                data: {name}
              });
            }
          }
          resolve();
        });
      });
    }));
    return result;
  }
  doHighlight() {
    let {nvim} = this;
    nvim.pauseNotification();
    nvim.command("syntax match CocHelptagsName /\\v^[^\\t]+/ contained containedin=CocHelptagsLine", true);
    nvim.command("syntax match CocHelptagsFile /\\t.*$/ contained containedin=CocHelptagsLine", true);
    nvim.command("highlight default link CocHelptagsName Identifier", true);
    nvim.command("highlight default link CocHelptagsFile Comment", true);
    nvim.resumeNotification(false, true);
  }
};
var helptags_default = Helptags;

// src/lines.ts
var import_coc6 = __toModule(require("coc.nvim"));
var Lines = class extends import_coc6.BasicList {
  constructor(nvim) {
    super(nvim);
    this.name = "lines";
    this.searchHighlight = false;
    this.interactive = true;
    this.description = "match lines of current buffer by regexp";
    this.detail = `Patterns are separated by space, pattern starts with '!' means nagitive.`;
    this.addLocationActions();
  }
  async loadItems(context) {
    let {input, window: window3} = context;
    if (!context.options.interactive) {
      throw new Error("lines list works on interactive mode only.");
    }
    if (!input.trim())
      return [];
    let valid = await window3.valid;
    if (!valid)
      return [];
    let buf = await window3.buffer;
    let doc = import_coc6.workspace.getDocument(buf.id);
    if (!doc)
      return [];
    let lines = await buf.lines;
    let result = [];
    let inputs = input.trim().split(/\s+/);
    let flags = context.options.ignorecase ? "iu" : "u";
    let patterns = [];
    let nagitives = [];
    for (let s of inputs) {
      try {
        let nagitive = s.startsWith("!");
        let re = new RegExp(nagitive ? s.slice(1) : s, flags);
        if (nagitive) {
          nagitives.push(re);
        } else {
          patterns.push(re);
        }
      } catch (_e) {
      }
    }
    if (patterns.length == 0 && nagitives.length == 0)
      return [];
    let hasNagitive = nagitives.length > 0;
    let total = lines.length.toString().length;
    let lnum = 0;
    for (let line of lines) {
      lnum = lnum + 1;
      if (hasNagitive && nagitives.some((r) => r.test(line))) {
        continue;
      }
      let ranges = [];
      for (let pattern of patterns) {
        let ms = line.match(pattern);
        if (ms == null)
          continue;
        ranges.push([ms.index, ms.index + ms[0].length]);
      }
      if (ranges.length != patterns.length) {
        continue;
      }
      let range = import_coc6.Range.create(lnum - 1, ranges[0][0], lnum - 1, ranges[0][1]);
      let pre = `${lnum}${pad(lnum.toString(), total)}`;
      let pl = pre.length;
      let ansiHighlights = ranges.map((r) => {
        return {
          span: [byteIndex(line, r[0]) + pl + 1, byteIndex(line, r[1]) + pl + 1],
          hlGroup: "CocListFgRed"
        };
      });
      ansiHighlights.push({
        span: [0, pl],
        hlGroup: "CocListFgMagenta"
      });
      result.push({
        ansiHighlights,
        label: `${pre} ${line}`,
        location: import_coc6.Location.create(doc.uri, range),
        filterText: ""
      });
    }
    return result;
  }
};
var lines_default = Lines;
function byteIndex(content, index) {
  let s = content.slice(0, index);
  return Buffer.byteLength(s);
}

// src/locationlist.ts
var import_coc7 = __toModule(require("coc.nvim"));
var LocationList = class extends import_coc7.BasicList {
  constructor(nvim) {
    super(nvim);
    this.name = "locationlist";
    this.defaultAction = "open";
    this.description = "locationlist of current window";
    this.addLocationActions();
  }
  async loadItems(context) {
    let {nvim} = this;
    let {window: window3} = context;
    let valid = await window3.valid;
    if (!valid)
      return [];
    let list = await nvim.call("getloclist", [window3.id]);
    if (list.length == 0)
      return [];
    let res = [];
    let buf = await context.window.buffer;
    let bufnr = buf.id;
    let ignoreFilepath = list.every((o) => o.bufnr && bufnr && o.bufnr == bufnr);
    for (let item of list) {
      let {bufnr: bufnr2, col, text, type, lnum} = item;
      if (type == "E") {
        type = "Error";
      } else if (type == "W") {
        type = "Warning";
      }
      let bufname = await nvim.call("bufname", bufnr2);
      let fullpath = await nvim.call("fnamemodify", [bufname, ":p"]);
      let uri = URI.file(fullpath).toString();
      let line = await import_coc7.workspace.getLine(uri, lnum - 1);
      let pos = import_coc7.Position.create(lnum - 1, characterIndex(line, col - 1));
      res.push({
        label: `${ignoreFilepath ? "" : bufname} |${type ? type + " " : ""}${lnum} col ${col}| ${text}`,
        location: import_coc7.Location.create(uri, import_coc7.Range.create(pos, pos)),
        filterText: `${ignoreFilepath ? "" : bufname}${text}`
      });
    }
    return res;
  }
  doHighlight() {
    let {nvim} = this;
    nvim.pauseNotification();
    nvim.command("syntax match CocLocationlistName /\\v^[^|]+/ contained containedin=CocLocationlistLine", true);
    nvim.command("syntax match CocLocationlistPosition /\\v\\|\\w*\\s?\\d+\\scol\\s\\d+\\|/ contained containedin=CocLocationlistLine", true);
    nvim.command("syntax match CocLocationlistError /Error/ contained containedin=CocLocationlistPosition", true);
    nvim.command("syntax match CocLocationlistWarning /Warning/ contained containedin=CocLocationlistPosition", true);
    nvim.command("highlight default link CocLocationlistName Directory", true);
    nvim.command("highlight default link CocLocationlistPosition LineNr", true);
    nvim.command("highlight default link CocLocationlistError Error", true);
    nvim.command("highlight default link CocLocationlistWarning WarningMsg", true);
    nvim.resumeNotification().catch((_e) => {
    });
  }
};
var locationlist_default = LocationList;

// src/maps.ts
var import_safe4 = __toModule(require_safe());
var regex5 = /^(\S+)\s+(\S+)\s+(.*)$/;
var Maps = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.name = "maps";
    this.description = "key mappings";
    this.defaultAction = "open";
    this.actions = [];
    this.options = [{
      name: "-mode=[i,n,v,x,s]",
      description: "Filter mappings by mode."
    }];
    this.actions.push({
      name: "open",
      execute: async (item) => {
        if (Array.isArray(item))
          return;
        let {mode, key} = item.data;
        let res = await nvim.eval(`split(execute("verbose ${mode}map ${key}"),"
")[-1]`);
        if (/Last\sset\sfrom/.test(res)) {
          let filepath = res.replace(/^\s+Last\sset\sfrom\s+/, "");
          nvim.command(`edit +/${key} ${filepath}`, true);
        }
      }
    });
  }
  async loadItems(context) {
    let {nvim} = this;
    let mode = "";
    for (let arg of context.args) {
      if (arg.startsWith("-mode=")) {
        mode = arg.replace("-mode=", "");
      }
    }
    let list = await nvim.eval(`split(execute("verbose ${mode}map"),"
")`);
    let res = [];
    for (let line of list) {
      let ms = line.match(regex5);
      if (ms) {
        let [, mode2, key, more] = ms;
        res.push({
          label: ` ${import_safe4.default.magenta(mode2)}	${import_safe4.default.blue(key)}	${more}`,
          filterText: `${key} ${more}`,
          data: {
            mode: mode2,
            key
          }
        });
      }
    }
    return res;
  }
};
var maps_default = Maps;

// src/marks.ts
var import_safe5 = __toModule(require_safe());
var regex6 = /^\s*(\S)\s+(\d+)\s+(\d+)\s*(.*)$/;
var Marks = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.name = "marks";
    this.description = "marks list";
    this.defaultAction = "jump";
    this.actions = [];
    this.actions.push({
      name: "jump",
      execute: (item) => {
        if (Array.isArray(item))
          return;
        nvim.command("normal! `" + item.data.name + "zz", true);
      }
    });
  }
  async loadItems(_context) {
    let {nvim} = this;
    let list = await nvim.eval('split(execute("marks"), "\n")');
    list = list.slice(1);
    list = list.filter((s) => regex6.test(s));
    return list.map((line) => {
      let [, name, lnum, col, text] = line.match(regex6);
      return {
        label: `${import_safe5.default.magenta(name)}	${text}	${import_safe5.default.grey(lnum)}	${import_safe5.default.grey(col)}`,
        filterText: name + " " + text,
        data: {name}
      };
    });
  }
};
var marks_default = Marks;

// src/mru.ts
var import_coc8 = __toModule(require("coc.nvim"));
var import_fs4 = __toModule(require("fs"));
var import_minimatch3 = __toModule(require_minimatch());
var import_path6 = __toModule(require("path"));
var MruList = class extends import_coc8.BasicList {
  constructor(nvim) {
    super(nvim);
    this.name = "mru";
    this.defaultAction = "open";
    this.description = "most recent used files in current cwd";
    this.detail = `Use command 'mru.validate' to remove files that not exists any more.`;
    this.options = [{
      name: "-A",
      description: "Show all recent files instead of filter by cwd."
    }];
    this.promise = Promise.resolve(void 0);
    this.mru = import_coc8.workspace.createMru("mru");
    this.addLocationActions();
    this.addAction("delete", async (item, _context) => {
      let filepath = URI.parse(item.data.uri).fsPath;
      await this.mru.remove(filepath);
    }, {reload: true, persist: true});
    this.addAction("clean", async () => {
      await this.mru.clean();
    }, {reload: true, persist: true});
    this.disposables.push(import_coc8.commands.registerCommand("mru.validate", async () => {
      let files = await this.mru.load();
      for (let file of files) {
        if (!import_fs4.default.existsSync(file)) {
          await this.mru.remove(file);
        }
      }
    }));
    for (let doc of import_coc8.workspace.documents) {
      this.addRecentFile(doc);
    }
    import_coc8.workspace.onDidOpenTextDocument(async (textDocument) => {
      await wait(50);
      let doc = import_coc8.workspace.getDocument(textDocument.uri);
      if (doc)
        this.addRecentFile(doc);
    }, null, this.disposables);
    import_coc8.events.on("BufEnter", (bufnr) => {
      let doc = import_coc8.workspace.getDocument(bufnr);
      if (doc)
        this.addRecentFile(doc);
    }, null, this.disposables);
  }
  addRecentFile(doc) {
    this.promise = this.promise.then(() => {
      return this._addRecentFile(doc);
    }, () => {
      return this._addRecentFile(doc);
    });
  }
  async _addRecentFile(doc) {
    let uri = URI.parse(doc.uri);
    if (uri.scheme !== "file" || doc.buftype != "")
      return;
    if (doc.filetype == "netrw")
      return;
    if (doc.uri.indexOf("NERD_tree") !== -1)
      return;
    let parts = uri.fsPath.split(import_path6.default.sep);
    if (parts.indexOf(".git") !== -1 || parts.length == 0)
      return;
    let preview = await this.nvim.eval(`getwinvar(bufwinnr(${doc.bufnr}), '&previewwindow')`);
    if (preview == 1)
      return;
    let filepath = uri.fsPath;
    let patterns = this.config.get("source.mru.excludePatterns", []);
    if (patterns.some((p) => import_minimatch3.default(filepath, p)))
      return;
    await this.mru.add(filepath);
  }
  async loadItems(context) {
    let cwd = context.cwd;
    let findAll = context.args.indexOf("-A") !== -1;
    let files = await this.mru.load();
    const range = import_coc8.Range.create(0, 0, 0, 0);
    if (!findAll)
      files = files.filter((file) => isParentFolder(cwd, file));
    return files.map((file, i) => {
      let uri = URI.file(file).toString();
      let location = import_coc8.Location.create(uri.toString(), range);
      return {
        label: findAll ? file : import_path6.default.relative(cwd, file),
        data: {uri},
        sortText: String.fromCharCode(i),
        location
      };
    });
  }
};
var mru_default = MruList;

// src/quickfix.ts
var import_coc9 = __toModule(require("coc.nvim"));
var QuickfixList = class extends import_coc9.BasicList {
  constructor(nvim) {
    super(nvim);
    this.name = "quickfix";
    this.defaultAction = "open";
    this.description = "quickfix list";
    this.addLocationActions();
  }
  async loadItems(context) {
    let {nvim} = this;
    let {window: window3} = context;
    let list = await nvim.call("getqflist");
    if (list.length == 0)
      return [];
    let res = [];
    let bufnr;
    let valid = await window3.valid;
    if (valid) {
      let buf = await window3.buffer;
      bufnr = buf.id;
    }
    let ignoreFilepath = list.every((o) => o.bufnr && bufnr && o.bufnr == bufnr);
    for (let item of list) {
      let {bufnr: bufnr2, col, text, type, lnum} = item;
      if (type == "E") {
        type = "Error";
      } else if (type == "W") {
        type = "Warning";
      }
      let bufname = await nvim.call("bufname", bufnr2);
      let fullpath = await nvim.call("fnamemodify", [bufname, ":p"]);
      let uri = URI.file(fullpath).toString();
      let line = await import_coc9.workspace.getLine(uri, lnum - 1);
      let pos = import_coc9.Position.create(lnum - 1, characterIndex(line, col - 1));
      res.push({
        label: `${ignoreFilepath ? "" : bufname} |${type ? type + " " : ""}${lnum} col ${col}| ${text}`,
        location: import_coc9.Location.create(uri, import_coc9.Range.create(pos, pos)),
        filterText: `${ignoreFilepath ? "" : bufname}${text}`
      });
    }
    return res;
  }
  doHighlight() {
    let {nvim} = this;
    nvim.pauseNotification();
    nvim.command("syntax match CocQuickfixName /\\v^[^|]+/ contained containedin=CocQuickfixLine", true);
    nvim.command("syntax match CocQuickfixPosition /\\v\\|\\w*\\s?\\d+\\scol\\s\\d+\\|/ contained containedin=CocQuickfixLine", true);
    nvim.command("syntax match CocQuickfixError /Error/ contained containedin=CocQuickfixPosition", true);
    nvim.command("syntax match CocQuickfixWarning /Warning/ contained containedin=CocQuickfixPosition", true);
    nvim.command("highlight default link CocQuickfixName Directory", true);
    nvim.command("highlight default link CocQuickfixPosition LineNr", true);
    nvim.command("highlight default link CocQuickfixError Error", true);
    nvim.command("highlight default link CocQuickfixWarning WarningMsg", true);
    nvim.resumeNotification().catch((_e) => {
    });
  }
};
var quickfix_default = QuickfixList;

// src/registers.ts
var import_safe6 = __toModule(require_safe());
var regex7 = /^[^\w]*(\w)[^\w|"]+(".)[^\w]+(.*)$/;
var Registers = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.name = "registers";
    this.description = "registers list";
    this.defaultAction = "append";
    this.actions = [];
    this.actions.push({
      name: "append",
      execute: (item) => {
        if (Array.isArray(item))
          return;
        nvim.command("normal! " + item.data.name + "p", true);
      }
    });
    this.actions.push({
      name: "prepend",
      execute: (item) => {
        if (Array.isArray(item))
          return;
        nvim.command("normal! " + item.data.name + "P", true);
      }
    });
  }
  async loadItems(_context) {
    const {nvim} = this;
    let list = await nvim.eval('split(execute("registers"), "\n")');
    list = list.slice(1);
    list = list.filter((s) => regex7.test(s));
    return list.map((line) => {
      let [, type, name, content] = line.match(regex7);
      return {
        label: `${import_safe6.default.grey(type)}	${import_safe6.default.magenta(name)}	${content}`,
        filterText: content,
        data: {name}
      };
    });
  }
};
var registers_default = Registers;

// src/searchhistory.ts
var regex8 = /^\s*\d+\s+(.*)$/;
var Searchhistory = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.name = "searchhistory";
    this.description = "search history";
    this.defaultAction = "feedkeys";
    this.actions = [];
    this.actions.push({
      name: "feedkeys",
      execute: async (item) => {
        if (Array.isArray(item))
          return;
        nvim.call("feedkeys", [`/${item.data.cmd}`, "n"], true);
      }
    });
  }
  async loadItems(_context) {
    let {nvim} = this;
    let list = await nvim.eval(`split(execute("history search"),"
")`);
    list = list.slice(1);
    let res = [];
    for (let line of list) {
      let ms = line.match(regex8);
      if (ms) {
        let [, cmd] = ms;
        res.push({
          label: cmd,
          filterText: cmd,
          data: {
            cmd
          }
        });
      }
    }
    return res;
  }
};
var searchhistory_default = Searchhistory;

// src/session.ts
var import_coc10 = __toModule(require("coc.nvim"));
var import_fs5 = __toModule(require("fs"));
var import_mkdirp = __toModule(require_mkdirp());
var import_os = __toModule(require("os"));
var import_path7 = __toModule(require("path"));
var import_util11 = __toModule(require("util"));
var SessionList = class extends import_coc10.BasicList {
  constructor(nvim, extensionPath) {
    super(nvim);
    this.extensionPath = extensionPath;
    this.name = "sessions";
    this.defaultAction = "load";
    this.description = "session list";
    this.detail = `After session load, coc service would be restarted.`;
    this.mru = import_coc10.workspace.createMru("sessions");
    this.addLocationActions();
    this.addAction("delete", async (item) => {
      let filepath = item.data.filepath;
      await this.mru.remove(filepath);
      await import_util11.promisify(import_fs5.default.unlink)(filepath);
    }, {reload: true, persist: true});
    this.addAction("load", async (item, _context) => {
      let filepath = item.data.filepath;
      await this.loadSession(filepath);
    });
    this.disposables.push(import_coc10.commands.registerCommand("session.save", async (name) => {
      setTimeout(async () => {
        if (!name) {
          name = await nvim.getVvar("this_session");
          if (!name) {
            let defaultValue = import_path7.default.basename(import_coc10.workspace.rootPath);
            name = await import_coc10.window.requestInput("session name", defaultValue);
            if (!name)
              return;
          }
        }
        if (!name.endsWith(".vim"))
          name = name + ".vim";
        let escaped;
        if (!import_path7.default.isAbsolute(name)) {
          let folder = await this.getSessionFolder();
          escaped = await nvim.call("fnameescape", [import_path7.default.join(folder, name)]);
        } else {
          escaped = await nvim.call("fnameescape", [name]);
          name = import_path7.default.basename(name, ".vim");
        }
        await nvim.command(`silent mksession! ${escaped}`);
        import_coc10.window.showMessage(`Saved session: ${name}`, "more");
      }, 50);
    }));
    this.disposables.push(import_coc10.commands.registerCommand("session.load", async (name) => {
      if (!name) {
        let folder = await this.getSessionFolder();
        let files = await import_util11.promisify(import_fs5.default.readdir)(folder, {encoding: "utf8"});
        files = files.filter((p) => p.endsWith(".vim"));
        files = files.map((p) => import_path7.default.basename(p, ".vim"));
        let idx = await import_coc10.window.showQuickpick(files, "choose session:");
        if (idx == -1)
          return;
        name = files[idx];
      }
      let filepath;
      if (import_path7.default.isAbsolute(name)) {
        filepath = name;
      } else {
        let folder = await this.getSessionFolder();
        filepath = import_path7.default.join(folder, name.endsWith(".vim") ? name : `${name}.vim`);
      }
      setTimeout(async () => {
        await this.loadSession(filepath);
      }, 30);
    }));
    this.disposables.push(import_coc10.commands.registerCommand("session.restart", async () => {
      if (!import_coc10.workspace.isNvim || process.env.TERM_PROGRAM != "iTerm.app") {
        import_coc10.window.showMessage("Sorry, restart support iTerm and neovim only.", "warning");
        return;
      }
      let filepath = await this.nvim.getVvar("this_session");
      if (!filepath) {
        let folder = await this.getSessionFolder();
        filepath = import_path7.default.join(folder, "default.vim");
      }
      await nvim.command(`silent mksession! ${filepath}`);
      let cwd = await nvim.call("getcwd");
      let cmd = `${import_path7.default.join(this.extensionPath, "nvimstart")} ${filepath} ${cwd}`;
      nvim.call("jobstart", [cmd, {detach: 1}], true);
      nvim.command("silent! wa | silent quitall!", true);
    }));
    let cfg = import_coc10.workspace.getConfiguration("session");
    let automake = cfg.get("saveOnVimLeave", true);
    if (automake) {
      this.disposables.push(import_coc10.workspace.registerAutocmd({
        event: "VimLeavePre",
        request: true,
        callback: async () => {
          let curr = await this.nvim.getVvar("this_session");
          if (!curr) {
            let folder = await this.getSessionFolder();
            curr = import_path7.default.join(folder, "default.vim");
          }
          await nvim.command(`silent mksession! ${curr}`);
        }
      }));
    }
  }
  async loadSession(filepath) {
    let {nvim} = this;
    let config = import_coc10.workspace.getConfiguration("session");
    let restart = config.get("restartOnSessionLoad", false);
    if (restart && import_coc10.workspace.isNvim && process.env.TERM_PROGRAM.startsWith("iTerm.app")) {
      let content = await import_util11.promisify(import_fs5.default.readFile)(filepath, "utf8");
      let line = content.split(/\r?\n/).find((s) => s.startsWith("cd "));
      let cwd = line.replace(/^cd\s+/, "");
      let cmd = `${import_path7.default.join(this.extensionPath, "nvimstart")} ${filepath} ${cwd}`;
      nvim.call("jobstart", [cmd, {detach: 1}], true);
      nvim.command("silent! wa | silent quitall!", true);
    } else {
      await this.mru.add(filepath);
      let escaped = await nvim.call("fnameescape", [filepath]);
      nvim.pauseNotification();
      nvim.command("noautocmd silent! %bwipeout!", true);
      nvim.command(`silent! source ${escaped}`, true);
      nvim.command("CocRestart", true);
      await nvim.resumeNotification(false, true);
    }
  }
  async getSessionFolder() {
    let config = import_coc10.workspace.getConfiguration("session");
    let directory = config.get("directory", "");
    directory = directory.replace(/^~/, import_os.default.homedir());
    const isWin = process.platform === "win32";
    if (!directory) {
      const folder = isWin ? "vimfiles/sessions" : ".vim/sessions";
      directory = import_path7.default.join(import_os.default.homedir(), folder);
    }
    if (!import_fs5.default.existsSync(directory)) {
      import_mkdirp.default.sync(directory);
      if (isWin) {
        let folder = import_path7.default.join(import_os.default.homedir(), ".vim/sessions");
        if (import_fs5.default.existsSync(folder)) {
          let stat = import_fs5.default.lstatSync(folder);
          if (stat && stat.isDirectory()) {
            let files = import_fs5.default.readdirSync(folder);
            for (let file of files) {
              if (file.endsWith(".vim")) {
                let dest = import_path7.default.join(import_os.default.homedir(), "vimfiles/sessions", file);
                import_fs5.default.copyFileSync(import_path7.default.join(folder, file), dest);
              }
            }
          }
        }
      }
    }
    return directory;
  }
  async loadItems(_context) {
    let folder = await this.getSessionFolder();
    let files = await import_util11.promisify(import_fs5.default.readdir)(folder, {encoding: "utf8"});
    files = files.filter((p) => p.endsWith(".vim"));
    let range = import_coc10.Range.create(0, 0, 0, 0);
    let curr = await this.nvim.getVvar("this_session");
    let arr = await Promise.all(files.map((file) => {
      let filepath = import_path7.default.join(folder, file);
      return import_util11.promisify(import_fs5.default.stat)(filepath).then((stat) => {
        return {
          atime: stat.atime,
          filepath
        };
      });
    }));
    arr.sort((a, b) => {
      return a.atime.getTime() - b.atime.getTime();
    });
    files = arr.map((o) => o.filepath);
    return files.map((filepath) => {
      let uri = import_coc10.Uri.file(filepath).toString();
      let location = import_coc10.Location.create(uri, range);
      let name = import_path7.default.basename(filepath, ".vim");
      let active = curr && curr == filepath;
      return {
        label: `${active ? "*" : " "} ${name}	${filepath}`,
        data: {filepath},
        location
      };
    });
  }
  doHighlight() {
    let {nvim} = this;
    nvim.pauseNotification();
    nvim.command("syntax match CocSessionsActivited /\\v^\\*/ contained containedin=CocSessionsLine", true);
    nvim.command("syntax match CocSessionsName /\\v%3c\\S+/ contained containedin=CocSessionsLine", true);
    nvim.command("syntax match CocSessionsRoot /\\v\\t[^\\t]*$/ contained containedin=CocSessionsLine", true);
    nvim.command("highlight default link CocSessionsActivited Special", true);
    nvim.command("highlight default link CocSessionsName Type", true);
    nvim.command("highlight default link CocSessionsRoot Comment", true);
    nvim.resumeNotification().catch((_e) => {
    });
  }
};
var session_default = SessionList;

// src/tags.ts
var import_coc11 = __toModule(require("coc.nvim"));
var import_safe7 = __toModule(require_safe());
var import_events3 = __toModule(require("events"));
var import_fs6 = __toModule(require("fs"));
var import_path8 = __toModule(require("path"));
var import_readline3 = __toModule(require("readline"));
var FileTask = class extends import_events3.EventEmitter {
  constructor() {
    super();
    this.streams = [];
  }
  start(files, cwd) {
    let count = files.length;
    for (let file of files) {
      let filepath = import_path8.default.isAbsolute(file) ? file : import_path8.default.join(cwd, file);
      if (!import_fs6.default.existsSync(filepath))
        continue;
      let stream = import_fs6.default.createReadStream(filepath, {encoding: "utf8"});
      this.streams.push(stream);
      const rl = import_readline3.default.createInterface({
        input: stream
      });
      let dirname = import_path8.default.dirname(filepath);
      rl.on("line", (line) => {
        if (line.startsWith("!"))
          return;
        let [name, file2, pattern] = line.split("	");
        if (!pattern)
          return;
        let fullpath = import_path8.default.join(dirname, file2);
        let uri = URI.file(fullpath).toString();
        let relativeFile = isParentFolder(cwd, fullpath) ? import_path8.default.relative(cwd, fullpath) : fullpath;
        this.emit("data", {
          label: `${import_safe7.default.blue(name)} ${import_safe7.default.grey(relativeFile)}`,
          filterText: name,
          location: {
            uri,
            line: pattern.replace(/^\/\^/, "").replace(/\$\/;?"?$/, ""),
            text: name
          }
        });
      });
      rl.on("error", (e) => {
        count = count - 1;
        this.emit("error", e.message);
      });
      rl.on("close", () => {
        count = count - 1;
        if (count == 0) {
          this.emit("end");
        }
      });
    }
  }
  dispose() {
    for (let stream of this.streams) {
      stream.close();
    }
  }
};
var Helptags2 = class extends import_coc11.BasicList {
  constructor(nvim) {
    super(nvim);
    this.name = "tags";
    this.description = "search from tags";
    this.defaultAction = "open";
    this.addLocationActions();
    this.disposables.push(import_coc11.commands.registerCommand("tags.generate", async () => {
      let config = import_coc11.workspace.getConfiguration("list.source.tags");
      let cmd = config.get("command", "ctags -R .");
      let res = await import_coc11.window.runTerminalCommand(cmd);
      if (res.success)
        import_coc11.window.showMessage("tagfile generated");
    }));
  }
  async loadItems(_context) {
    let {nvim} = this;
    let cwd = await nvim.call("getcwd");
    let tagfiles = await nvim.call("tagfiles");
    if (!tagfiles || tagfiles.length == 0) {
      throw new Error('no tag files found, use ":CocCommand tags.generate" to generate tagfile.');
    }
    let task = new FileTask();
    task.start(tagfiles, cwd);
    return task;
  }
};
var tags_default = Helptags2;

// src/windows.ts
var import_safe8 = __toModule(require_safe());
var Windows = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.name = "windows";
    this.description = "windows list";
    this.defaultAction = "jump";
    this.actions = [];
    this.actions.push({
      name: "jump",
      execute: (item) => {
        if (Array.isArray(item))
          return;
        nvim.call("win_gotoid", item.data.id, true);
      }
    });
  }
  async loadItems(_context) {
    let {nvim} = this;
    let wins = await nvim.call("getwininfo");
    let res = [];
    for (let win of wins) {
      let bufname = await nvim.call("bufname", win.bufnr);
      res.push({
        label: `${import_safe8.default.yellow(win.tabnr.toString())}	${import_safe8.default.yellow(win.winnr.toString())}	${bufname}`,
        data: {id: win.winid}
      });
    }
    return res;
  }
};
var windows_default = Windows;

// src/words.ts
var import_coc12 = __toModule(require("coc.nvim"));
var import_safe9 = __toModule(require_safe());
var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
var Words = class extends import_coc12.BasicList {
  constructor(nvim) {
    super(nvim);
    this.name = "words";
    this.searchHighlight = false;
    this.interactive = true;
    this.description = "word matches of current buffer";
    this.options = [{
      name: "-w, -word",
      description: "Match word boundary."
    }];
    this.addLocationActions();
  }
  async loadItems(context) {
    let {input, window: window3} = context;
    if (!input)
      return [];
    let valid = await window3.valid;
    if (!valid)
      return [];
    let buf = await window3.buffer;
    let doc = import_coc12.workspace.getDocument(buf.id);
    if (!doc)
      return;
    let {args} = context;
    let wordMatch = args.indexOf("-w") !== -1 || args.indexOf("-word") !== -1;
    let content = doc.getDocumentContent();
    let result = [];
    let lnum = 1;
    let total = doc.lineCount.toString().length;
    let flags = context.options.ignorecase ? "iu" : "u";
    let source = input.replace(matchOperatorsRe, "\\$&");
    if (wordMatch)
      source = `\\b${source}\\b`;
    let regex9 = new RegExp(source, flags);
    let replaceRegex = new RegExp(source, flags + "g");
    for (let line of content.split("\n")) {
      let ms = line.match(regex9);
      if (ms) {
        let range = import_coc12.Range.create(lnum - 1, ms.index, lnum - 1, ms.index + input.length);
        let pre = `${import_safe9.default.magenta(lnum.toString())}${pad(lnum.toString(), total)}`;
        let text = line.replace(replaceRegex, (match) => {
          return import_safe9.default.red(match);
        });
        result.push({
          label: `${pre} ${text}`,
          location: import_coc12.Location.create(doc.uri, range),
          filterText: ""
        });
      }
      lnum = lnum + 1;
    }
    return result;
  }
};
var words_default = Words;

// src/index.ts
async function activate(context) {
  let {subscriptions} = context;
  let config = import_coc13.workspace.getConfiguration("lists");
  let disabled = config.get("disabledLists", []);
  let {nvim} = import_coc13.workspace;
  function isDisabled(name) {
    return disabled.indexOf(name) !== -1;
  }
  if (!isDisabled("lines")) {
    subscriptions.push(import_coc13.listManager.registerList(new lines_default(nvim)));
  }
  if (!isDisabled("session")) {
    subscriptions.push(import_coc13.listManager.registerList(new session_default(nvim, context.extensionPath)));
  }
  if (!isDisabled("cmdhistory")) {
    subscriptions.push(import_coc13.listManager.registerList(new cmdhistory_default(nvim)));
  }
  if (!isDisabled("searchhistory")) {
    subscriptions.push(import_coc13.listManager.registerList(new searchhistory_default(nvim)));
  }
  if (!isDisabled("vimcommands")) {
    subscriptions.push(import_coc13.listManager.registerList(new commands_default(nvim)));
  }
  if (!isDisabled("maps")) {
    subscriptions.push(import_coc13.listManager.registerList(new maps_default(nvim)));
  }
  if (!isDisabled("colors")) {
    subscriptions.push(import_coc13.listManager.registerList(new colors_default(nvim)));
  }
  if (!isDisabled("windows")) {
    subscriptions.push(import_coc13.listManager.registerList(new windows_default(nvim)));
  }
  if (!isDisabled("marks")) {
    subscriptions.push(import_coc13.listManager.registerList(new marks_default(nvim)));
  }
  if (!isDisabled("filetypes")) {
    subscriptions.push(import_coc13.listManager.registerList(new filetypes_default(nvim)));
  }
  if (!isDisabled("files")) {
    subscriptions.push(import_coc13.listManager.registerList(new files_default(nvim)));
  }
  if (!isDisabled("tags")) {
    subscriptions.push(import_coc13.listManager.registerList(new tags_default(nvim)));
  }
  if (!isDisabled("helptags")) {
    subscriptions.push(import_coc13.listManager.registerList(new helptags_default(nvim)));
  }
  if (!isDisabled("registers")) {
    subscriptions.push(import_coc13.listManager.registerList(new registers_default(nvim)));
  }
  if (!isDisabled("buffers")) {
    subscriptions.push(import_coc13.listManager.registerList(new buffers_default(nvim)));
  }
  if (!isDisabled("changes")) {
    subscriptions.push(import_coc13.listManager.registerList(new changes_default(nvim)));
  }
  if (!isDisabled("grep")) {
    subscriptions.push(import_coc13.listManager.registerList(new grep_default(nvim)));
  }
  if (!isDisabled("LocationList")) {
    subscriptions.push(import_coc13.listManager.registerList(new locationlist_default(nvim)));
  }
  if (!isDisabled("mru")) {
    subscriptions.push(import_coc13.listManager.registerList(new mru_default(nvim)));
  }
  if (!isDisabled("quickfix")) {
    subscriptions.push(import_coc13.listManager.registerList(new quickfix_default(nvim)));
  }
  if (!isDisabled("words")) {
    subscriptions.push(import_coc13.listManager.registerList(new words_default(nvim)));
  }
}
//# sourceMappingURL=index.js.map
